<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#0a0a2a">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Kaden & Adelynn Adventures">
    <meta name="format-detection" content="telephone=no">
    
    <!-- Additional PWA meta tags for better compatibility -->
    <meta name="application-name" content="Kaden & Adelynn Adventures">
    <meta name="msapplication-TileColor" content="#0a0a2a">
    <meta name="msapplication-config" content="none">
    
    <!-- Cache busting - update this version number when you make changes -->
    <meta name="version" content="1.0.19">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <title>Kaden & Adelynn Adventures</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json?v=1.0.19">
    
    <!-- Firebase SDK -->
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, collection, addDoc, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyC1b-JWvBRGti5LFKk7LqSS8p1QFbP_D88",
            authDomain: "kaden---adelynn-adventures.firebaseapp.com",
            projectId: "kaden---adelynn-adventures",
            storageBucket: "kaden---adelynn-adventures.firebasestorage.app",
            messagingSenderId: "265116401918",
            appId: "1:265116401918:web:e1511695b92aeb05e0e5af",
            measurementId: "G-W4Q02R318L"
        };

        // Global Firebase state
        window.firebaseState = {
            initialized: false,
            auth: null,
            db: null,
            analytics: null,
            currentUser: null,
            error: null
        };

        // Initialize Firebase with better error handling
        try {
            const app = initializeApp(firebaseConfig);
            const db = getFirestore(app);
            const auth = getAuth(app);

            // Initialize analytics only if supported
            let analytics = null;
            try {
                if (typeof window !== 'undefined' && window.indexedDB) {
                    analytics = getAnalytics(app);
                }
            } catch (analyticsError) {
                console.log('Firebase: Analytics not supported in this environment');
            }

            // Make Firebase available globally
            window.firebaseApp = app;
            window.firebaseAuth = auth;
            window.firebaseDb = db;
            window.firebaseAnalytics = analytics;
            window.firebaseState.auth = auth;
            window.firebaseState.db = db;
            window.firebaseState.analytics = analytics;
            window.firebaseState.initialized = true;

            console.log('Firebase: Successfully initialized');

            // Enable anonymous authentication for multiplayer score tracking
            signInAnonymously(auth)
                .then((userCredential) => {
                    window.currentUser = userCredential.user;
                    window.firebaseState.currentUser = window.currentUser;
                    console.log('Firebase: Anonymous authentication successful');
                })
                .catch((error) => {
                    console.warn('Firebase: Authentication error (will use localStorage fallback):', error.message);
                    // Set up mock user for localStorage-only mode
                    window.currentUser = {
                        uid: 'local-user-' + Date.now(),
                        isAnonymous: true,
                        displayName: 'Anonymous'
                    };
                    window.firebaseState.currentUser = window.currentUser;
                });

        } catch (error) {
            console.warn('Firebase: Initialization error (will use localStorage fallback):', error.message);
            window.firebaseState.error = error.message;
            
            // Set up mock user for localStorage-only mode
            window.currentUser = {
                uid: 'local-user-' + Date.now(),
                isAnonymous: true,
                displayName: 'Anonymous'
            };
            window.firebaseState.currentUser = window.currentUser;
        }

        // Robust Firebase functions with comprehensive fallbacks
        window.firebaseFunctions = {
            // Save high score to Firebase with fallback
            saveHighScore: async (score, playerName = 'Anonymous') => {
                // Always save to localStorage first for reliability
                saveHighScoreToLocal(score, playerName);
                
                // Try Firebase if available and authenticated
                if (!window.firebaseState.initialized || !window.firebaseState.currentUser || window.firebaseState.error) {
                    console.log('Firebase: Using localStorage fallback for high score (not authenticated or initialized)');
                    return;
                }
                
                try {
                    const scoreData = {
                        playerName: playerName,
                        score: score,
                        timestamp: new Date().toISOString(),
                        userId: window.firebaseState.currentUser.uid
                    };
                    
                    await addDoc(collection(window.firebaseState.db, 'highScores'), scoreData);
                    console.log('Firebase: High score saved successfully for multiplayer tracking');
                } catch (error) {
                    console.warn('Firebase: Error saving high score (using localStorage):', error.message);
                    // localStorage already saved above, so no action needed
                }
            },

            // Get top high scores with fallback
            getHighScores: async () => {
                // Always return from localStorage for immediate response
                const localScores = getHighScoresFromLocal();
                
                // Try Firebase if available and authenticated
                if (!window.firebaseState.initialized || window.firebaseState.error) {
                    console.log('Firebase: Using localStorage fallback for high scores (not initialized)');
                    return localScores;
                }
                
                try {
                    const q = query(collection(window.firebaseState.db, 'highScores'), orderBy('score', 'desc'), limit(10));
                    const querySnapshot = await getDocs(q);
                    const firebaseScores = [];
                    querySnapshot.forEach((doc) => {
                        firebaseScores.push(doc.data());
                    });
                    
                    // Merge Firebase and localStorage scores for true multiplayer leaderboard
                    const allScores = [...localScores, ...firebaseScores];
                    allScores.sort((a, b) => b.score - a.score);
                    const topScores = allScores.slice(0, 10);
                    
                    console.log('Firebase: Multiplayer leaderboard loaded successfully');
                    return topScores;
                } catch (error) {
                    console.warn('Firebase: Error getting high scores (using localStorage):', error.message);
                    return localScores;
                }
            },

            // Save game stats with fallback
            saveGameStats: async (stats) => {
                // Always save to localStorage first
                saveGameStatsToLocal(stats);
                
                // Try Firebase if available and no auth errors
                if (!window.firebaseState.initialized || !window.firebaseState.currentUser || window.firebaseState.error) {
                    console.log('Firebase: Using localStorage fallback for game stats (auth error or not initialized)');
                    return;
                }
                
                try {
                    const statsData = {
                        ...stats,
                        userId: window.firebaseState.currentUser.uid,
                        timestamp: new Date().toISOString()
                    };
                    
                    await addDoc(collection(window.firebaseState.db, 'gameStats'), statsData);
                    console.log('Firebase: Game stats saved successfully');
                } catch (error) {
                    console.warn('Firebase: Error saving game stats (using localStorage):', error.message);
                    // localStorage already saved above, so no action needed
                }
            },

            // Track game event with fallback
            trackEvent: (eventName, parameters = {}) => {
                // Always log locally
                console.log('Game Event:', eventName, parameters);
                
                // Try Firebase analytics if available
                if (window.firebaseState.initialized && window.firebaseState.analytics) {
                    try {
                        window.firebaseState.analytics.logEvent(eventName, parameters);
                        console.log('Firebase: Event tracked:', eventName);
                    } catch (error) {
                        console.warn('Firebase: Analytics error (using local logging):', error.message);
                    }
                }
            },

            // Check Firebase status
            getStatus: () => {
                return {
                    initialized: window.firebaseState.initialized,
                    authenticated: !!window.firebaseState.currentUser,
                    error: window.firebaseState.error
                };
            }
        };

        // Enhanced localStorage functions
        function saveHighScoreToLocal(score, playerName) {
            try {
                const scores = JSON.parse(localStorage.getItem('highScores') || '[]');
                scores.push({ playerName, score, timestamp: new Date().toISOString() });
                scores.sort((a, b) => b.score - a.score);
                scores.splice(10); // Keep only top 10
                localStorage.setItem('highScores', JSON.stringify(scores));
                console.log('LocalStorage: High score saved successfully');
            } catch (error) {
                console.error('LocalStorage: Error saving high score:', error);
            }
        }

        function getHighScoresFromLocal() {
            try {
                const scores = JSON.parse(localStorage.getItem('highScores') || '[]');
                return scores.slice(0, 10); // Return top 10
            } catch (error) {
                console.error('LocalStorage: Error getting high scores:', error);
                return [];
            }
        }

        function saveGameStatsToLocal(stats) {
            try {
                const gameStats = JSON.parse(localStorage.getItem('gameStats') || '[]');
                gameStats.push({ ...stats, timestamp: new Date().toISOString() });
                gameStats.splice(50); // Keep only last 50 games
                localStorage.setItem('gameStats', JSON.stringify(gameStats));
                console.log('LocalStorage: Game stats saved successfully');
            } catch (error) {
                console.error('LocalStorage: Error saving game stats:', error);
            }
        }

        // Initialize game data on load
        window.addEventListener('load', () => {
            console.log('Firebase Status:', window.firebaseFunctions.getStatus());
        });
    </script>
    
    <!-- Simple Icon Approach - Test -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='45' fill='%230a0a2a'/><text x='50' y='65' font-size='50' text-anchor='middle' fill='white'>🚀</text></svg>">
    
    <!-- Apple Touch Icon - Simple -->
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='45' fill='%230a0a2a'/><text x='50' y='65' font-size='50' text-anchor='middle' fill='white'>🚀</text></svg>">
    
    <!-- Standard Favicon Files -->
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="48x48" href="favicon-48x48.png">
    
    <!-- Simple Rocket Emoji Favicon - Clean Start -->
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48dGV4dCB5PSIuOWVtIiBmb250LXNpemU9IjkwIiBmaWxsPSJ3aGl0ZSI+8J+RqDwvdGV4dD48L3N2Zz4=">
    
    <!-- Apple Touch Icons for iOS -->
    <link rel="apple-touch-icon" sizes="180x180" href="icon-180x180.png">
    <link rel="apple-touch-icon" sizes="152x152" href="icon-152x152.png">
    <link rel="apple-touch-icon" sizes="144x144" href="icon-144x144.png">
    <link rel="apple-touch-icon" sizes="120x120" href="icon-120x120.png">
    <link rel="apple-touch-icon" sizes="114x114" href="icon-114x114.png">
    <link rel="apple-touch-icon" sizes="76x76" href="icon-76x76.png">
    <link rel="apple-touch-icon" sizes="72x72" href="icon-72x72.png">
    <link rel="apple-touch-icon" sizes="60x60" href="icon-60x60.png">
    <link rel="apple-touch-icon" sizes="57x57" href="icon-57x57.png">
    <link rel="apple-touch-icon" href="icon-180x180.png">
    
    <!-- Additional icon formats for better compatibility -->
    <link rel="icon" type="image/png" sizes="32x32" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48dGV4dCB5PSIuOWVtIiBmb250LXNpemU9IjkwIiBmaWxsPSJ3aGl0ZSI+8J+RqDwvdGV4dD48L3N2Zz4=">
    <link rel="icon" type="image/png" sizes="16x16" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48dGV4dCB5PSIuOWVtIiBmb250LXNpemU9IjkwIiBmaWxsPSJ3aGl0ZSI+8J+RqDwvdGV4dD48L3N2Zz4=">
    
    <!-- Standard favicon and Apple touch icons -->
    <link rel="icon" href="./favicon.ico">
    <link rel="apple-touch-icon" href="./icon-144x144.png">
    
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0a0a2a 0%, #1a1a4a 50%, #0a0a2a 100%);
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-y: auto;
            min-height: 100vh;
        }
        
        #gameContainer {
            text-align: center;
        }
        
        #mainMenu {
            text-align: center;
            z-index: 10;
        }
        
        #gameCanvas {
            border: 3px solid #4a90e2;
            background: linear-gradient(to bottom, #000033 0%, #000066 100%);
            margin: 20px 0;
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.5);
            display: none;
        }
        
        #gameUI {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: white;
            font-family: 'Courier New', monospace;
            z-index: 10;
            display: none;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            padding: 6px 10px;
            backdrop-filter: blur(5px);
        }
        
        #controls {
            margin: 0;
            text-align: right;
        }
        
        #controls p {
            margin: 0 0 5px 0;
            font-size: 11px;
            opacity: 0.8;
        }
        
        #menuBtn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 8px;
            margin: 5px;
            transition: all 0.3s ease;
            min-width: 120px;
        }
        
        #menuBtn:hover {
            background: linear-gradient(45deg, #ee5a52, #ff6b6b);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        
        #pauseBtn {
            background: linear-gradient(45deg, #4a90e2, #357abd);
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 8px;
            margin: 5px;
            transition: all 0.3s ease;
            min-width: 120px;
        }
        
        #pauseBtn:hover {
            background: linear-gradient(45deg, #357abd, #4a90e2);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(74, 144, 226, 0.4);
        }
        
        #storeBtn {
            background: linear-gradient(45deg, #ffd700, #ffb347);
            color: white;
            border: none;
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
            margin: 0 0 0 10px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }
        
        #storeBtn:hover {
            background: linear-gradient(45deg, #ffb347, #ffd700);
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.4);
        }
        
        #store {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(20, 20, 60, 0.95) 100%);
            border: 3px solid #ffd700;
            border-radius: 15px;
            padding: 20px;
            z-index: 200;
            display: none;
            box-shadow: 0 10px 40px rgba(255, 215, 0, 0.3);
            backdrop-filter: blur(10px);
            min-width: 400px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        #store::-webkit-scrollbar {
            width: 8px;
        }
        
        #store::-webkit-scrollbar-track {
            background: rgba(255, 215, 0, 0.1);
            border-radius: 4px;
        }
        
        #store::-webkit-scrollbar-thumb {
            background: linear-gradient(45deg, #ffd700, #ffb347);
            border-radius: 4px;
        }
        
        #store::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(45deg, #ffb347, #ffd700);
        }
        
        #store h2 {
            color: #ffd700;
            text-align: center;
            margin-bottom: 20px;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .store-item {
            background: rgba(74, 144, 226, 0.1);
            border: 1px solid #4a90e2;
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }
        
        .store-item:hover {
            background: rgba(74, 144, 226, 0.2);
            transform: translateX(5px);
        }
        
        .store-item-info {
            flex: 1;
        }
        
        .store-item-name {
            color: #4a90e2;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 4px;
        }
        
        .store-item-description {
            color: #87ceeb;
            font-size: 12px;
            margin-bottom: 4px;
        }
        
        .store-item-cost {
            color: #ffd700;
            font-size: 14px;
            font-weight: bold;
        }
        
        .store-item-button {
            background: linear-gradient(45deg, #4a90e2, #357abd);
            color: white;
            border: none;
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            border-radius: 4px;
            margin-left: 10px;
            transition: all 0.3s ease;
        }
        
        .store-item-button:hover {
            background: linear-gradient(45deg, #357abd, #4a90e2);
            transform: scale(1.05);
        }
        
        .store-item-button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .store-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #ffd700;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .store-close:hover {
            color: #fff;
            transform: scale(1.1);
        }
        
        .store-category {
            margin: 20px 0 10px 0;
            padding: 8px 12px;
            background: linear-gradient(45deg, #ffd700, #ffb347);
            border-radius: 8px;
            color: #000;
            font-weight: bold;
            font-size: 16px;
            text-align: center;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .store-exit {
            background: linear-gradient(45deg, #ff4444, #cc0000);
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 8px;
            margin-top: 15px;
            width: 100%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }
        
        .store-exit:hover {
            background: linear-gradient(45deg, #cc0000, #ff4444);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
        }
        
        #scoreBoard {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(20, 20, 60, 0.95) 100%);
            border: 2px solid #4a90e2;
            border-radius: 15px;
            padding: 12px 20px;
            z-index: 50;
            display: none;
            box-shadow: 0 6px 20px rgba(74, 144, 226, 0.4);
            backdrop-filter: blur(15px);
            min-width: 400px;
            animation: scoreboardGlow 3s ease-in-out infinite alternate;
            font-family: 'Courier New', monospace;
            max-width: 90vw;
        }
        
        @keyframes scoreboardGlow {
            from {
                box-shadow: 0 6px 20px rgba(74, 144, 226, 0.4);
                border-color: #4a90e2;
            }
            to {
                box-shadow: 0 6px 25px rgba(74, 144, 226, 0.7);
                border-color: #5ba0f2;
            }
        }
        
        #score {
            font-size: 16px;
            margin: 8px 0;
            color: #4a90e2;
            text-shadow: 0 0 12px rgba(74, 144, 226, 0.8);
            font-weight: bold;
            font-family: 'Courier New', monospace;
            letter-spacing: 0.8px;
            line-height: 1.4;
            text-align: center;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        #stats {
            font-size: 13px;
            margin: 6px 0;
            color: #87ceeb;
            text-shadow: 0 0 10px rgba(135, 206, 235, 0.6);
            font-family: 'Courier New', monospace;
            line-height: 1.3;
            text-align: center;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        #powerupInfo {
            font-size: 11px;
            color: #ffd700;
            margin: 6px 0;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
            font-family: 'Courier New', monospace;
            line-height: 1.2;
            text-align: center;
        }
        
        button {
            background: linear-gradient(45deg, #4a90e2, #357abd);
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: linear-gradient(45deg, #357abd, #4a90e2);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        
        .menu-title {
            font-size: 48px;
            color: #4a90e2;
            text-shadow: 0 0 20px rgba(74, 144, 226, 0.7);
            margin-bottom: 30px;
        }
        
        .menu-subtitle {
            font-size: 18px;
            color: #87ceeb;
            margin-bottom: 40px;
        }
        
        .menu-instructions {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #4a90e2;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            max-width: 600px;
        }

        /* Medal Modal Styles */
        #medalModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .medal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 3px solid #ffd700;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 30px rgba(255, 215, 0, 0.3);
            animation: medalGlow 2s ease-in-out infinite alternate;
        }

        @keyframes medalGlow {
            0% { box-shadow: 0 10px 30px rgba(255, 215, 0, 0.3); }
            100% { box-shadow: 0 15px 40px rgba(255, 215, 0, 0.6); }
        }

        .medal-header h2 {
            color: #ffd700;
            margin: 0 0 20px 0;
            font-size: 24px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .medal-icon {
            font-size: 60px;
            margin: 20px 0;
            animation: medalBounce 1s ease-in-out infinite;
        }

        @keyframes medalBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .medal-body {
            color: white;
            margin: 20px 0;
        }

        .medal-body p {
            margin: 10px 0;
            font-size: 16px;
        }

        .name-input {
            margin: 20px 0;
        }

        .name-input label {
            display: block;
            color: #ffd700;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .name-input input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ffd700;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 16px;
            text-align: center;
        }

        .name-input input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .medal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
        }

        .claim-btn {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #000;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .claim-btn:hover {
            background: linear-gradient(45deg, #ffed4e, #ffd700);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.4);
        }

        .skip-btn {
            background: linear-gradient(45deg, #666, #999);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .skip-btn:hover {
            background: linear-gradient(45deg, #777, #aaa);
            transform: translateY(-2px);
        }

        /* Leaderboard Display Styles */
        .leaderboard-section {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #ffd700;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            max-width: 600px;
        }

        .leaderboard-title {
            color: #ffd700;
            font-size: 24px;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 2px 4px rgba(255, 215, 0, 0.5);
        }

        .medal-entry {
            display: flex;
            align-items: center;
            margin: 15px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border-left: 4px solid #ffd700;
        }

        .medal-entry.gold {
            border-left-color: #ffd700;
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.1), transparent);
        }

        .medal-entry.silver {
            border-left-color: #c0c0c0;
            background: linear-gradient(90deg, rgba(192, 192, 192, 0.1), transparent);
        }

        .medal-entry.bronze {
            border-left-color: #cd7f32;
            background: linear-gradient(90deg, rgba(205, 127, 50, 0.1), transparent);
        }

        .medal-rank {
            font-size: 24px;
            margin-right: 15px;
            min-width: 40px;
        }

        .medal-info {
            flex: 1;
            color: white;
        }

        .medal-name {
            font-weight: bold;
            font-size: 18px;
            color: #ffd700;
        }

        .medal-score {
            font-size: 16px;
            color: #87ceeb;
        }

        .medal-date {
            font-size: 12px;
            color: #999;
        }

        #score span, #stats span {
            background: rgba(74, 144, 226, 0.1);
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid rgba(74, 144, 226, 0.3);
            white-space: nowrap;
            transition: all 0.3s ease;
        }
        
        #score span:hover, #stats span:hover {
            background: rgba(74, 144, 226, 0.2);
            border-color: rgba(74, 144, 226, 0.5);
            transform: translateY(-1px);
        }
        
        #stats span {
            background: rgba(135, 206, 235, 0.1);
            border-color: rgba(135, 206, 235, 0.3);
        }
        
        #stats span:hover {
            background: rgba(135, 206, 235, 0.2);
            border-color: rgba(135, 206, 235, 0.5);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="mainMenu">
            <h1 class="menu-title">Kaden & Adelynn Adventures</h1>
            <p class="menu-subtitle">Space Shooter Adventure</p>
            <button id="startBtn">Start Game</button>
            <p><strong>Highest Score:</strong> <span id="highScoreDisplay">0</span></p>
            
            <div class="menu-instructions">
                <h3>How to Play:</h3>
                <p><strong>Movement:</strong> Arrow Keys</p>
                <p><strong>Shoot:</strong> Spacebar</p>
                <p><strong>Power-ups:</strong></p>
                <ul style="text-align: left; display: inline-block;">
                    <li>⚡ Lightning = Speed Boost</li>
                    <li>🚀 Missile = Double Shot</li>
                    <li>🛡️ Shield = Shield Protection</li>
                </ul>
                <p><strong>Objective:</strong> Destroy enemy ships and survive as long as possible!</p>
            </div>
            
            <div class="menu-instructions">
                <h3>🎮 Game Features:</h3>
                <ul style="text-align: left; display: inline-block;">
                    <li>🚀 Gradius-style power-up system</li>
                    <li>⭐ Beautiful star field background</li>
                    <li>🎯 Multiple enemy types & Boss battles</li>
                    <li>🏆 Score tracking & High score system</li>
                    <li>💫 Smooth 60 FPS gameplay</li>
                    <li>🎨 Detailed ship designs</li>
                    <li>🏪 Complete store system with 20+ items</li>
                    <li>🚀 5 unique ships with different abilities</li>
                    <li>💰 Money & Diamond economy system</li>
                    <li>🎯 Challenge system with objectives</li>
                    <li>🛡️ Advanced protection & shield items</li>
                    <li>⚡ Energy boost & weapon upgrades</li>
                    <li>📱 Touch controls for mobile devices</li>
                    <li>🔊 Sound effects & audio system</li>
                    <li>🎨 Professional UI with categories</li>
                </ul>
            </div>
            
            <div class="menu-instructions">
                <h3>📖 The Story:</h3>
                <p>Join Kaden & Adelynn on their epic space adventure! As brave space pilots, you must navigate through dangerous asteroid fields and battle waves of enemy ships. Collect power-ups to enhance your ship's capabilities and achieve the highest score possible!</p>
                <p>Can you survive the longest and become the ultimate space warrior?</p>
            </div>
            
            <div class="menu-instructions">
                <h3>🎯 Tips for Success:</h3>
                <ul style="text-align: left; display: inline-block;">
                    <li>Keep moving to avoid enemy fire</li>
                    <li>Collect power-ups whenever possible</li>
                    <li>Prioritize fast enemies (orange) for more points</li>
                    <li>Use the shield power-up strategically</li>
                    <li>Practice your shooting accuracy</li>
                    <li>Collect 💵 money and 💎 diamonds for store purchases</li>
                    <li>Visit the store to upgrade your ship and abilities</li>
                    <li>Choose ships based on your playstyle</li>
                    <li>Complete challenges for bonus points</li>
                    <li>Save diamonds for permanent upgrades</li>
                </ul>
            </div>
            
            <div class="leaderboard-section">
                <h3 class="leaderboard-title">🏅 CHAMPION HALL OF FAME 🏅</h3>
                <div id="leaderboardDisplay">
                    <div class="medal-entry gold">
                        <div class="medal-rank">🥇</div>
                        <div class="medal-info">
                            <div class="medal-name">Champion</div>
                            <div class="medal-score">0 points</div>
                            <div class="medal-date">Crowned: Never</div>
                        </div>
                    </div>
                    <div class="medal-entry silver">
                        <div class="medal-rank">🥈</div>
                        <div class="medal-info">
                            <div class="medal-name">Runner</div>
                            <div class="medal-score">0 points</div>
                            <div class="medal-date">Achieved: Never</div>
                        </div>
                    </div>
                    <div class="medal-entry bronze">
                        <div class="medal-rank">🥉</div>
                        <div class="medal-info">
                            <div class="medal-name">Player</div>
                            <div class="medal-score">0 points</div>
                            <div class="medal-date">Earned: Never</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="menu-instructions">
                <h3>🌟 Credits:</h3>
                <p><strong>Game:</strong> Kaden & Adelynn Adventures</p>
                <p><strong>Style:</strong> Gradius-inspired Space Shooter</p>
                <p><strong>Technology:</strong> HTML5 Canvas & JavaScript</p>
                <p><strong>Features:</strong> Power-ups, Store System, Ship Upgrades, Challenge System, Touch Controls, Sound Effects</p>
            </div>
        </div>
        
        <canvas id="gameCanvas" width="1000" height="700"></canvas>
        
        <div id="scoreBoard">
            <div id="score">
                <span>Score: 0</span>
                <span>Lives: 25</span>
                <span>Kills: 0</span>
            </div>
            <div id="stats">
                <span>Power: Basic</span>
                <span>Consecutive: 0</span>
                <span>Survival: 0s</span>
                <span>💵: 0</span>
                <span>💎: 0</span>
            </div>
        </div>
        
        <div id="gameUI">
            <div id="controls">
                <button id="menuBtn">Back to Menu</button>
                <button id="pauseBtn" onclick="togglePause()">⏸️ Pause</button>
                <button id="storeBtn">💎 Store</button>
            </div>
        </div>
        
        <!-- Medal Modal -->
        <div id="medalModal" style="display: none;">
            <div class="medal-content">
                <div class="medal-header">
                    <h2 id="medalTitle">🏅 MEDAL ACHIEVED! 🏅</h2>
                    <div id="medalIcon" class="medal-icon">🥉</div>
                </div>
                <div class="medal-body">
                    <p id="medalMessage">You've earned a medal!</p>
                    <p><strong>Score:</strong> <span id="medalScore">0</span> points</p>
                    <p><strong>Rank:</strong> <span id="medalRank">#3</span></p>
                    <div class="name-input">
                        <label for="playerName">Enter your name:</label>
                        <input type="text" id="playerName" maxlength="15" placeholder="Your name (max 15 chars)">
                    </div>
                </div>
                <div class="medal-buttons">
                    <button onclick="claimMedal()" class="claim-btn">🏅 Claim Medal</button>
                    <button onclick="skipMedal()" class="skip-btn">Skip</button>
                </div>
            </div>
        </div>

        <div id="store">
            <button class="store-close" onclick="closeStore()">×</button>
            <h2>💎 Space Store</h2>
            <div style="text-align: center; margin-bottom: 10px; padding: 10px; background: linear-gradient(45deg, #4a90e2, #357abd); border-radius: 8px; font-size: 16px; color: white; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                🚀 Welcome to Kaden & Adelynn Space Store! 🚀
            </div>
            <div style="text-align: center; margin-bottom: 15px; padding: 8px; background: rgba(255, 255, 0, 0.1); border: 1px solid #ffd700; border-radius: 5px; font-size: 12px; color: #ffd700;">
                ⚠️ DISCLAIMER: This store uses FAKE GAME CURRENCY earned through gameplay. No real money required!
            </div>
            
            <div class="store-category">🛡️ Shield & Protection</div>
            <div class="store-item">
                <div class="store-item-info">
                    <div class="store-item-name">Shield Recharge</div>
                    <div class="store-item-description">Restore shield if lost</div>
                    <div class="store-item-cost">Cost: 25 💵</div>
                </div>
                <button class="store-item-button" onclick="buyShieldRecharge()">Buy</button>
            </div>
            <div class="store-item">
                <div class="store-item-info">
                    <div class="store-item-name">Diamond Shield</div>
                    <div class="store-item-description">Blocks 3 hits (permanent)</div>
                    <div class="store-item-cost">Cost: 8 💎</div>
                </div>
                <button class="store-item-button" onclick="buyDiamondShield()">Buy</button>
            </div>
            <div class="store-item">
                <div class="store-item-info">
                    <div class="store-item-name">Force Field</div>
                    <div class="store-item-description">Blocks all damage for 15 seconds</div>
                    <div class="store-item-cost">Cost: 40 💵</div>
                </div>
                <button class="store-item-button" onclick="buyForceField()">Buy</button>
            </div>
            <div class="store-item">
                <div class="store-item-info">
                    <div class="store-item-name">Invincibility Cloak</div>
                    <div class="store-item-description">Become invisible to enemies for 10 seconds</div>
                    <div class="store-item-cost">Cost: 12 💎</div>
                </div>
                <button class="store-item-button" onclick="buyInvincibilityCloak()">Buy</button>
            </div>
            
            <div class="store-category">💖 Extra Life</div>
            <div class="store-item">
                <div class="store-item-info">
                    <div class="store-item-name">Extra Life</div>
                    <div class="store-item-description">Gain 1 additional life</div>
                    <div class="store-item-cost">Cost: 50 💵</div>
                </div>
                <button class="store-item-button" onclick="buyExtraLife()">Buy</button>
            </div>
            <div class="store-item">
                <div class="store-item-info">
                    <div class="store-item-name">Life Pack</div>
                    <div class="store-item-description">Gain 3 additional lives</div>
                    <div class="store-item-cost">Cost: 120 💵</div>
                </div>
                <button class="store-item-button" onclick="buyLifePack()">Buy</button>
            </div>
            <div class="store-item">
                <div class="store-item-info">
                    <div class="store-item-name">Auto-Revive</div>
                    <div class="store-item-description">Automatically revive once when destroyed</div>
                    <div class="store-item-cost">Cost: 6 💎</div>
                </div>
                <button class="store-item-button" onclick="buyAutoRevive()">Buy</button>
            </div>
            
            <div class="store-category">⚡ Energy Boost</div>
            <div class="store-item">
                <div class="store-item-info">
                    <div class="store-item-name">Emergency Boost</div>
                    <div class="store-item-description">Speed + fire rate boost</div>
                    <div class="store-item-cost">Cost: 20 💵</div>
                </div>
                <button class="store-item-button" onclick="buyEmergencyBoost()">Buy</button>
            </div>
            <div class="store-item">
                <div class="store-item-info">
                    <div class="store-item-name">Score Multiplier</div>
                    <div class="store-item-description">2x score for 30 seconds</div>
                    <div class="store-item-cost">Cost: 30 💵</div>
                </div>
                <button class="store-item-button" onclick="buyScoreMultiplier()">Buy</button>
            </div>
            <div class="store-item">
                <div class="store-item-info">
                    <div class="store-item-name">Diamond Storm</div>
                    <div class="store-item-description">Rapid-fire all weapons for 10 seconds</div>
                    <div class="store-item-cost">Cost: 15 💎</div>
                </div>
                <button class="store-item-button" onclick="buyDiamondStorm()">Buy</button>
            </div>
            <div class="store-item">
                <div class="store-item-info">
                    <div class="store-item-name">Speed Demon</div>
                    <div class="store-item-description">3x movement speed for 20 seconds</div>
                    <div class="store-item-cost">Cost: 35 💵</div>
                </div>
                <button class="store-item-button" onclick="buySpeedDemon()">Buy</button>
            </div>
            <div class="store-item">
                <div class="store-item-info">
                    <div class="store-item-name">Time Warp</div>
                    <div class="store-item-description">Slow down enemies for 15 seconds</div>
                    <div class="store-item-cost">Cost: 10 💎</div>
                </div>
                <button class="store-item-button" onclick="buyTimeWarp()">Buy</button>
            </div>
            
            <div class="store-category">🔫 Weapons</div>
            <div class="store-item">
                <div class="store-item-info">
                    <div class="store-item-name">Bullet Damage +1</div>
                    <div class="store-item-description">Permanent damage upgrade</div>
                    <div class="store-item-cost">Cost: 5 💎</div>
                </div>
                <button class="store-item-button" onclick="buyBulletDamage()">Buy</button>
            </div>
            <div class="store-item">
                <div class="store-item-info">
                    <div class="store-item-name">Boss Weakness</div>
                    <div class="store-item-description">2x damage to bosses for 1 minute</div>
                    <div class="store-item-cost">Cost: 3 💎</div>
                </div>
                <button class="store-item-button" onclick="buyBossWeakness()">Buy</button>
            </div>
            <div class="store-item">
                <div class="store-item-info">
                    <div class="store-item-name">Triple Shot</div>
                    <div class="store-item-description">Fire 3 bullets at once for 25 seconds</div>
                    <div class="store-item-cost">Cost: 45 💵</div>
                </div>
                <button class="store-item-button" onclick="buyTripleShot()">Buy</button>
            </div>
            <div class="store-item">
                <div class="store-item-info">
                    <div class="store-item-name">Laser Beam</div>
                    <div class="store-item-description">Continuous laser beam for 12 seconds</div>
                    <div class="store-item-cost">Cost: 8 💎</div>
                </div>
                <button class="store-item-button" onclick="buyLaserBeam()">Buy</button>
            </div>
            <div class="store-item">
                <div class="store-item-info">
                    <div class="store-item-name">Missile Launcher</div>
                    <div class="store-item-description">Powerful missiles that track enemies</div>
                    <div class="store-item-cost">Cost: 7 💎</div>
                </div>
                <button class="store-item-button" onclick="buyMissileLauncher()">Buy</button>
            </div>
            
            <div class="store-category">🚀 Ships</div>
            <div class="store-item">
                <div class="store-item-info">
                    <div class="store-item-name">🚀 Interceptor</div>
                    <div class="store-item-description">Fast and agile fighter with enhanced damage</div>
                    <div class="store-item-cost">Cost: 100 💵</div>
                </div>
                <button class="store-item-button" onclick="buyShip('interceptor')">Buy</button>
            </div>
            <div class="store-item">
                <div class="store-item-info">
                    <div class="store-item-name">💥 Destroyer</div>
                    <div class="store-item-description">Heavy damage dealer, slower but powerful</div>
                    <div class="store-item-cost">Cost: 200 💵</div>
                </div>
                <button class="store-item-button" onclick="buyShip('destroyer')">Buy</button>
            </div>
            <div class="store-item">
                <div class="store-item-info">
                    <div class="store-item-name">⚡ Scout</div>
                    <div class="store-item-description">Ultra-fast with rapid fire rate</div>
                    <div class="store-item-cost">Cost: 150 💵</div>
                </div>
                <button class="store-item-button" onclick="buyShip('scout')">Buy</button>
            </div>
            <div class="store-item">
                <div class="store-item-info">
                    <div class="store-item-name">🛡️ Tank</div>
                    <div class="store-item-description">Maximum survivability with extra lives</div>
                    <div class="store-item-cost">Cost: 300 💵</div>
                </div>
                <button class="store-item-button" onclick="buyShip('tank')">Buy</button>
            </div>
            
            <button class="store-exit" onclick="closeStore()">Exit Store</button>
        </div>
    </div>

    <script>
        // Enhanced Space Shooter Game with Gradius Features
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const menuBtn = document.getElementById('menuBtn');
        const mainMenu = document.getElementById('mainMenu');
        const gameUI = document.getElementById('gameUI');
        const scoreBoard = document.getElementById('scoreBoard');
        const scoreDisplay = document.getElementById('score');
        const powerupInfo = document.getElementById('powerupInfo');
        const statsDisplay = document.getElementById('stats');
        const highScoreDisplay = document.getElementById('highScoreDisplay');

        // Game variables
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let lives = 25;
        let highScore = 0;
        let level = 1;
        let playerPower = null;
        let doubleShot = false;
        let shieldActive = false;
        let shieldTimer = 0;
        let starPowerActive = false;
        let starPowerTimer = 0;
        let fireRateBoost = false;
        let rapidFireActive = false;
        let rapidFireTimer = 0;
        let rapidFireCooldown = 100; // Milliseconds between rapid fire shots
        let bullets = [];
        let enemyBullets = [];
        let enemies = [];
        let powerups = [];
        let stars = [];
        let keys = {};
        let player = { x: 475, y: 600, width: 50, height: 40 };
        let shotCooldown = 200;
        let lastShot = 0;
        let gameStarted = false;
        let isMobile = false;
        let audioContext = null;
        
        // Weapon system
        let currentWeapon = 'basic';
        let weaponLevel = 1;
        let weapons = {
            basic: {
                name: 'Basic Laser',
                damage: 1,
                fireRate: 1,
                bulletSpeed: 8,
                bulletSize: { width: 4, height: 8 },
                color: '#ffd700',
                description: 'Standard laser beam'
            },
            plasma: {
                name: 'Plasma Cannon',
                damage: 2,
                fireRate: 0.8,
                bulletSpeed: 6,
                bulletSize: { width: 6, height: 12 },
                color: '#00ffff',
                description: 'High damage plasma bolts'
            },
            spread: {
                name: 'Spread Shot',
                damage: 1,
                fireRate: 1.2,
                bulletSpeed: 7,
                bulletSize: { width: 3, height: 6 },
                color: '#ff6b6b',
                description: 'Multiple projectiles in a spread pattern'
            },
            laser: {
                name: 'Laser Beam',
                damage: 1.5,
                fireRate: 1.5,
                bulletSpeed: 10,
                bulletSize: { width: 2, height: 20 },
                color: '#ff1493',
                description: 'Fast continuous laser beam'
            },
            missile: {
                name: 'Homing Missile',
                damage: 3,
                fireRate: 0.6,
                bulletSpeed: 5,
                bulletSize: { width: 8, height: 16 },
                color: '#ff4500',
                description: 'Slow but powerful homing missiles'
            },
            lightning: {
                name: 'Lightning Bolt',
                damage: 2.5,
                fireRate: 0.7,
                bulletSpeed: 12,
                bulletSize: { width: 4, height: 15 },
                color: '#ffff00',
                description: 'Fast lightning strikes'
            },
            ice: {
                name: 'Ice Shard',
                damage: 1.5,
                fireRate: 1.1,
                bulletSpeed: 9,
                bulletSize: { width: 5, height: 10 },
                color: '#87ceeb',
                description: 'Freezing projectiles that slow enemies'
            },
            fire: {
                name: 'Fireball',
                damage: 2,
                fireRate: 0.9,
                bulletSpeed: 7,
                bulletSize: { width: 6, height: 12 },
                color: '#ff6347',
                description: 'Explosive fireballs'
            },
            energy: {
                name: 'Energy Pulse',
                damage: 1.8,
                fireRate: 1.3,
                bulletSpeed: 8,
                bulletSize: { width: 4, height: 8 },
                color: '#32cd32',
                description: 'Sustained energy pulses'
            },
            quantum: {
                name: 'Quantum Blaster',
                damage: 4,
                fireRate: 0.5,
                bulletSpeed: 6,
                bulletSize: { width: 7, height: 14 },
                color: '#8a2be2',
                description: 'Powerful quantum energy blasts'
            },
            sonic: {
                name: 'Sonic Wave',
                damage: 1.2,
                fireRate: 1.4,
                bulletSpeed: 9,
                bulletSize: { width: 3, height: 8 },
                color: '#ff69b4',
                description: 'High-frequency sonic waves'
            }
        };
        
        // Dynamic difficulty scaling based on score
        let enemySpawnRate = 0.06; // Increased from 0.04 for more enemies on screen
        let enemySpeedMultiplier = 1.2; // Reduced from 1.5 for more balanced speed
        let bossActive = false;
        let bossHealth = 0;
        let bossMaxHealth = 0;
        
        // Challenge system variables
        let challenges = [];
        let currentChallenge = null;
        let challengeProgress = 0;
        let challengeTarget = 0;
        let challengeReward = 0;
        let challengeTimer = 0;
        let challengeActive = false;
        let totalEnemiesDestroyed = 0;
        let totalPowerupsCollected = 0;
        let totalDiamondsCollected = 0;
        let totalMoneyCollected = 0;
        let consecutiveHits = 0;
        let maxConsecutiveHits = 0;
        let survivalTime = 0;
        let startTime = 0;
        let challengeCompleteMessage = '';
        let challengeCompleteTimer = 0;
        
        // Store and enhanced collectible system
        let money = 0;
        let diamonds = 0;
        let bulletDamage = 1;
        let diamondShield = 0;
        let diamondStormActive = false;
        let diamondStormTimer = 0;
        let bossDamageMultiplier = 1;
        let bossDamageTimer = 0;
        let scoreMultiplier = 1;
        let scoreMultiplierTimer = 0;
        let storeOpen = false;
        
        // Top 3 Medal System
        let top3Leaderboard = {
            gold: { name: "Champion", score: 0, date: "2024-01-01" },
            silver: { name: "Runner", score: 0, date: "2024-01-01" },
            bronze: { name: "Player", score: 0, date: "2024-01-01" }
        };
        let medalModalOpen = false;
        let currentMedal = null;
        let medalAnimationTimer = 0;
        let medalAnimationActive = false;
        
        // Ship system
        let currentShip = 'basic';
        let availableShips = ['basic'];
        let ships = {
            basic: {
                name: 'Basic Fighter',
                cost: 0,
                damage: 1,
                speed: 1,
                fireRate: 1,
                health: 1,
                description: 'Standard fighter ship'
            },
            interceptor: {
                name: 'Interceptor',
                cost: 100,
                damage: 1.5,
                speed: 1.3,
                fireRate: 1.2,
                health: 1,
                description: 'Fast and agile fighter'
            },
            destroyer: {
                name: 'Destroyer',
                cost: 200,
                damage: 2,
                speed: 0.8,
                fireRate: 0.9,
                health: 2,
                description: 'Heavy damage, slower speed'
            },
            scout: {
                name: 'Scout',
                cost: 150,
                damage: 1,
                speed: 1.5,
                fireRate: 1.5,
                health: 0.8,
                description: 'Ultra-fast with rapid fire'
            },
            tank: {
                name: 'Tank',
                cost: 300,
                damage: 1.5,
                speed: 0.7,
                fireRate: 1,
                health: 3,
                description: 'Maximum survivability'
            }
        };

        // Initialize stars
        for (let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                speed: 0.5 + Math.random() * 1.5
            });
        }

        // Sound effects
        function playMissileSound() {
            try {
                // Create a simple missile sound using Web Audio API
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('Audio context created');
                }
                
                // Resume audio context if suspended
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log('Audio context resumed');
                        createMissileSound();
                    });
                } else {
                    createMissileSound();
                }
            } catch (error) {
                console.log('Sound error:', error);
            }
        }
        
        function createMissileSound() {
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
                
                // Sound played successfully
            } catch (error) {
                console.log('Create sound error:', error);
            }
        }

        // Detect mobile device
        function detectMobile() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            return isMobile;
        }

        // Event listeners
        startBtn.addEventListener('click', () => {
            console.log('Start button clicked!');
            startGame();
        });
        menuBtn.addEventListener('click', backToMenu);
        document.getElementById('storeBtn').addEventListener('click', openStore);
        
        document.addEventListener('keydown', (e) => {
            // Check if name input is focused - if so, don't capture game controls
            const nameInput = document.getElementById('playerName');
            if (nameInput && document.activeElement === nameInput) {
                return; // Allow normal typing in the name input
            }
            
            keys[e.code] = true;
            if (e.code === 'Space') {
                e.preventDefault();
                handleShoot(e);
            }
            if (e.code === 'KeyP') activatePowerup();
            
            // Weapon switching
            if (e.code === 'Digit1') switchWeapon('basic');
            if (e.code === 'Digit2') switchWeapon('plasma');
            if (e.code === 'Digit3') switchWeapon('spread');
            if (e.code === 'Digit4') switchWeapon('laser');
            if (e.code === 'Digit5') switchWeapon('missile');
            if (e.code === 'Digit6') switchWeapon('lightning');
            if (e.code === 'Digit7') switchWeapon('ice');
            if (e.code === 'Digit8') switchWeapon('fire');
            if (e.code === 'Digit9') switchWeapon('energy');
            if (e.code === 'Digit0') switchWeapon('quantum');
            if (e.code === 'Minus') switchWeapon('sonic');
            
            // Pause/Resume controls
            if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') {
                if (gameRunning) {
                    e.preventDefault();
                    togglePause();
                }
            }
            
            // Menu key
            if (e.key === 'm' || e.key === 'M') {
                if (gameRunning && gamePaused) {
                    e.preventDefault();
                    backToMenu();
                }
            }
        });
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Touch controls for mobile
        let touchActive = false;
        let lastTouchTime = 0;
        let touchCooldown = 200; // Milliseconds between shots
        
        // Canvas touch events for mobile
        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('touchend', handleTouchEnd);
        
        function handleTouchStart(e) {
            e.preventDefault();
            if (!gameRunning) return;
            
            touchActive = true;
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            // Move player to touch position
            player.x = Math.max(0, Math.min(x - player.width / 2, canvas.width - player.width));
            player.y = Math.max(0, Math.min(y - player.height / 2, canvas.height - player.height));
            
            // Shoot on touch
            const now = Date.now();
            if (now - lastTouchTime > touchCooldown) {
                if (doubleShot) {
                    bullets.push({ x: player.x + 5, y: player.y, width: 4, height: 8, speed: 8 });
                    bullets.push({ x: player.x + 15, y: player.y, width: 4, height: 8, speed: 8 });
                    bullets.push({ x: player.x + 25, y: player.y, width: 4, height: 8, speed: 8 });
                    bullets.push({ x: player.x + 35, y: player.y, width: 4, height: 8, speed: 8 });
                    playMissileSound();
                } else {
                    bullets.push({ x: player.x + 18, y: player.y, width: 4, height: 8, speed: 8 });
                    playMissileSound();
                }
                lastTouchTime = now;
            }
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            if (!gameRunning || !touchActive) return;
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            // Move player to touch position
            player.x = Math.max(0, Math.min(x - player.width / 2, canvas.width - player.width));
            player.y = Math.max(0, Math.min(y - player.height / 2, canvas.height - player.height));
            
            // Shoot while moving (with cooldown)
            const now = Date.now();
            if (now - lastTouchTime > touchCooldown) {
                if (doubleShot) {
                    bullets.push({ x: player.x + 5, y: player.y, width: 4, height: 8, speed: 8 });
                    bullets.push({ x: player.x + 15, y: player.y, width: 4, height: 8, speed: 8 });
                    bullets.push({ x: player.x + 25, y: player.y, width: 4, height: 8, speed: 8 });
                    bullets.push({ x: player.x + 35, y: player.y, width: 4, height: 8, speed: 8 });
                    playMissileSound();
                } else {
                    bullets.push({ x: player.x + 18, y: player.y, width: 4, height: 8, speed: 8 });
                    playMissileSound();
                }
                lastTouchTime = now;
            }
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            touchActive = false;
        }

        function handleShoot(e) {
            e.preventDefault();
            if (gameRunning) {
                const now = Date.now();
                const weapon = weapons[currentWeapon];
                const normalShotCooldown = shotCooldown / weapon.fireRate;
                
                // Handle rapid fire
                if (rapidFireActive && now - lastShot > rapidFireCooldown) {
                    // Rapid fire creates bullets more frequently
                    const bulletConfig = {
                        x: player.x + player.width / 2 - weapon.bulletSize.width / 2,
                        y: player.y,
                        width: weapon.bulletSize.width,
                        height: weapon.bulletSize.height,
                        speed: weapon.bulletSpeed,
                        color: weapon.color,
                        type: currentWeapon,
                        damage: weapon.damage
                    };
                    
                    bullets.push(bulletConfig);
                    playMissileSound();
                    lastShot = now;
                } else if (keys['Space'] && now - lastShot > normalShotCooldown) {
                    // Create bullets based on current weapon
                    const bulletConfig = {
                        x: player.x + player.width / 2 - weapon.bulletSize.width / 2,
                        y: player.y,
                        width: weapon.bulletSize.width,
                        height: weapon.bulletSize.height,
                        speed: weapon.bulletSpeed,
                        color: weapon.color,
                        type: currentWeapon,
                        damage: weapon.damage
                    };
                    
                    if (doubleShot) {
                        // Double shot creates multiple bullets
                        bullets.push({ ...bulletConfig, x: player.x + 5 });
                        bullets.push({ ...bulletConfig, x: player.x + 15 });
                        bullets.push({ ...bulletConfig, x: player.x + 25 });
                        bullets.push({ ...bulletConfig, x: player.x + 35 });
                    } else {
                        // Single shot
                        bullets.push(bulletConfig);
                    }
                    
                    // Special weapon effects
                    if (currentWeapon === 'spread') {
                        // Spread shot creates diagonal bullets
                        bullets.push({
                            ...bulletConfig,
                            speedX: -2,
                            speedY: -weapon.bulletSpeed
                        });
                        bullets.push({
                            ...bulletConfig,
                            speedX: 2,
                            speedY: -weapon.bulletSpeed
                        });
                    }
                    
                    if (currentWeapon === 'missile') {
                        // Missiles have homing capability
                        bulletConfig.homing = true;
                    }
                    
                    playMissileSound();
                    lastShot = now;
                }
            }
        }

        function handlePowerup(e) {
            e.preventDefault();
            if (gameRunning) {
                activatePowerup();
            }
        }

        function startGame() {
            gameRunning = true;
            gamePaused = false;
            gameStarted = true;
            score = 0;
            lives = 3;
            level = 1;
            playerPower = null;
            doubleShot = false;
            shieldActive = false;
            shieldTimer = 0;
            starPowerActive = false;
            starPowerTimer = 0;
            rapidFireActive = false;
            rapidFireTimer = 0;
            rapidFireCooldown = 100; // Milliseconds between rapid fire shots
            bullets = [];
            enemyBullets = [];
            enemies = [];
            powerups = [];
            playerPower = 'basic';
            doubleShot = false;
            shieldActive = false;
            shieldTimer = 0;
            starPowerActive = false;
            starPowerTimer = 0;
            rapidFireActive = false;
            rapidFireTimer = 0;
            rapidFireCooldown = 100; // Milliseconds between rapid fire shots
            shotCooldown = 200;
            lastShot = 0;
            enemySpawnRate = 0.06; // Increased from 0.04 for more enemies on screen
            enemySpeedMultiplier = 1.2; // Reduced from 1.5 for more balanced speed
            bossActive = false;
            bossHealth = 0;
            bossMaxHealth = 0;
            totalEnemiesDestroyed = 0;
            totalPowerupsCollected = 0;
            totalDiamondsCollected = 0;
            totalMoneyCollected = 0;
            consecutiveHits = 0;
            maxConsecutiveHits = 0;
            survivalTime = 0;
            startTime = Date.now();
            challengeActive = false;
            currentChallenge = null;
            challengeProgress = 0;
            challengeTarget = 0;
            challengeReward = 0;
            challengeTimer = 0;
            challengeCompleteMessage = '';
            challengeCompleteTimer = 0;
            money = 0;
            diamonds = 0;
            bulletDamage = 1;
            diamondShield = 0;
            diamondStormActive = false;
            diamondStormTimer = 0;
            bossDamageMultiplier = 1;
            bossDamageTimer = 0;
            scoreMultiplier = 1;
            scoreMultiplierTimer = 0;
            storeOpen = false;
            currentShip = 'basic';
            
            // Reset pause button
            document.getElementById('pauseBtn').textContent = '⏸️ Pause';
            
            // Initialize stars
            stars = [];
            for (let i = 0; i < 100; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    speed: 0.5 + Math.random() * 1.5
                });
            }
            
            // Initialize challenges
            initializeChallenges();
            
            // Start random challenge after 10 seconds
            setTimeout(() => {
                if (gameRunning) {
                    startRandomChallenge();
                }
            }, 10000);
            
            // Show game UI and canvas
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('gameUI').style.display = 'block';
            scoreBoard.style.display = 'block';
            canvas.style.display = 'block';
            
            // Start game loop
            gameLoop();
            
            console.log('Game started!');
        }

        function backToMenu() {
            gameRunning = false;
            gamePaused = false;
            gameStarted = false;
            document.getElementById('mainMenu').style.display = 'block';
            canvas.style.display = 'none';
            document.getElementById('gameUI').style.display = 'none';
            scoreBoard.style.display = 'none';
            console.log('Returned to menu');
        }

        function drawPlayerShip() {
            ctx.save();
            ctx.translate(player.x + player.width/2, player.y + player.height/2);
            
            const ship = ships[currentShip];
            
            // Draw different ship designs based on type
            if (currentShip === 'basic') {
                drawBasicShip();
            } else if (currentShip === 'interceptor') {
                drawInterceptorShip();
            } else if (currentShip === 'destroyer') {
                drawDestroyerShip();
            } else if (currentShip === 'scout') {
                drawScoutShip();
            } else if (currentShip === 'tank') {
                drawTankShip();
            }
            
            // Shield effect
            if (shieldActive) {
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Star power effect
            if (starPowerActive) {
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, 35, 0, Math.PI * 2);
                ctx.stroke();
                
                // Add star particles
                ctx.fillStyle = '#ffff00';
                for (let i = 0; i < 8; i++) {
                    const angle = (i * Math.PI * 2) / 8;
                    const x = Math.cos(angle) * 40;
                    const y = Math.sin(angle) * 40;
                    ctx.fillRect(x - 1, y - 1, 2, 2);
                }
            }
            
            ctx.restore();
        }
        
        function drawBasicShip() {
            // Main body
            ctx.fillStyle = '#4a90e2';
            ctx.beginPath();
            ctx.moveTo(0, -20);
            ctx.lineTo(-12, 15);
            ctx.lineTo(-8, 20);
            ctx.lineTo(8, 20);
            ctx.lineTo(12, 15);
            ctx.closePath();
            ctx.fill();
            
            // Cockpit
            ctx.fillStyle = '#87ceeb';
            ctx.beginPath();
            ctx.ellipse(0, 0, 4, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Wings
            ctx.fillStyle = '#357abd';
            ctx.fillRect(-16, 8, 6, 12);
            ctx.fillRect(10, 8, 6, 12);
            
            // Engine glow
            ctx.fillStyle = '#ff6b35';
            ctx.fillRect(-4, 20, 8, 4);
        }
        
        function drawInterceptorShip() {
            // Sleek, fast design
            ctx.fillStyle = '#00ff88';
            ctx.beginPath();
            ctx.moveTo(0, -25);
            ctx.lineTo(-8, 10);
            ctx.lineTo(-15, 15);
            ctx.lineTo(-10, 20);
            ctx.lineTo(10, 20);
            ctx.lineTo(15, 15);
            ctx.lineTo(8, 10);
            ctx.closePath();
            ctx.fill();
            
            // Advanced cockpit
            ctx.fillStyle = '#00ccff';
            ctx.beginPath();
            ctx.ellipse(0, -5, 3, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Aerodynamic wings
            ctx.fillStyle = '#008855';
            ctx.fillRect(-20, 5, 8, 15);
            ctx.fillRect(12, 5, 8, 15);
            
            // Dual engines
            ctx.fillStyle = '#ff4444';
            ctx.fillRect(-6, 20, 4, 6);
            ctx.fillRect(2, 20, 4, 6);
        }
        
        function drawDestroyerShip() {
            // Heavy, powerful design
            ctx.fillStyle = '#ff6600';
            ctx.beginPath();
            ctx.moveTo(0, -18);
            ctx.lineTo(-18, 8);
            ctx.lineTo(-20, 15);
            ctx.lineTo(-15, 22);
            ctx.lineTo(15, 22);
            ctx.lineTo(20, 15);
            ctx.lineTo(18, 8);
            ctx.closePath();
            ctx.fill();
            
            // Reinforced cockpit
            ctx.fillStyle = '#ffaa00';
            ctx.beginPath();
            ctx.ellipse(0, 0, 6, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Heavy armor plates
            ctx.fillStyle = '#cc4400';
            ctx.fillRect(-22, 8, 10, 16);
            ctx.fillRect(12, 8, 10, 16);
            
            // Powerful engine
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(-8, 22, 16, 8);
        }
        
        function drawScoutShip() {
            // Small, agile design
            ctx.fillStyle = '#8844ff';
            ctx.beginPath();
            ctx.moveTo(0, -22);
            ctx.lineTo(-6, 8);
            ctx.lineTo(-10, 12);
            ctx.lineTo(-8, 18);
            ctx.lineTo(8, 18);
            ctx.lineTo(10, 12);
            ctx.lineTo(6, 8);
            ctx.closePath();
            ctx.fill();
            
            // Compact cockpit
            ctx.fillStyle = '#aa88ff';
            ctx.beginPath();
            ctx.ellipse(0, -2, 2, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Small wings
            ctx.fillStyle = '#6644cc';
            ctx.fillRect(-12, 6, 4, 10);
            ctx.fillRect(8, 6, 4, 10);
            
            // Quick engine
            ctx.fillStyle = '#ff88ff';
            ctx.fillRect(-3, 18, 6, 3);
        }
        
        function drawTankShip() {
            // Massive, armored design
            ctx.fillStyle = '#666666';
            ctx.beginPath();
            ctx.moveTo(0, -20);
            ctx.lineTo(-20, 5);
            ctx.lineTo(-25, 12);
            ctx.lineTo(-20, 20);
            ctx.lineTo(20, 20);
            ctx.lineTo(25, 12);
            ctx.lineTo(20, 5);
            ctx.closePath();
            ctx.fill();
            
            // Armored cockpit
            ctx.fillStyle = '#999999';
            ctx.beginPath();
            ctx.ellipse(0, 0, 8, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Heavy armor
            ctx.fillStyle = '#444444';
            ctx.fillRect(-25, 8, 12, 18);
            ctx.fillRect(13, 8, 12, 18);
            
            // Massive engine
            ctx.fillStyle = '#ff6600';
            ctx.fillRect(-10, 20, 20, 10);
        }

        function drawEnemyShip(x, y, type = 'basic') {
            ctx.save();
            ctx.translate(x + 20, y + 20);
            
            switch(type) {
                case 'basic':
                    // Basic enemy - red triangle
                    ctx.fillStyle = '#ff4444';
                    ctx.beginPath();
                    ctx.moveTo(0, 16);
                    ctx.lineTo(-12, -12);
                    ctx.lineTo(-8, -16);
                    ctx.lineTo(8, -16);
                    ctx.lineTo(12, -12);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Enemy cockpit
                    ctx.fillStyle = '#ff8888';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 3, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'fast':
                    // Fast enemy - orange small ship
                    ctx.fillStyle = '#ff8844';
                    ctx.beginPath();
                    ctx.moveTo(0, 12);
                    ctx.lineTo(-10, -10);
                    ctx.lineTo(-6, -12);
                    ctx.lineTo(6, -12);
                    ctx.lineTo(10, -10);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case 'tank':
                    // Tank enemy - large blue ship
                    ctx.fillStyle = '#4444ff';
                    ctx.beginPath();
                    ctx.moveTo(0, 20);
                    ctx.lineTo(-16, -16);
                    ctx.lineTo(-12, -20);
                    ctx.lineTo(12, -20);
                    ctx.lineTo(16, -16);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Tank armor plates
                    ctx.fillStyle = '#6666ff';
                    ctx.fillRect(-8, -8, 16, 4);
                    ctx.fillRect(-6, -4, 12, 4);
                    break;
                    
                case 'scout':
                    // Scout enemy - small green ship
                    ctx.fillStyle = '#44ff44';
                    ctx.beginPath();
                    ctx.moveTo(0, 8);
                    ctx.lineTo(-6, -8);
                    ctx.lineTo(-4, -10);
                    ctx.lineTo(4, -10);
                    ctx.lineTo(6, -8);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case 'bomber':
                    // Bomber enemy - large purple ship
                    ctx.fillStyle = '#8844ff';
                    ctx.beginPath();
                    ctx.moveTo(0, 18);
                    ctx.lineTo(-14, -14);
                    ctx.lineTo(-10, -18);
                    ctx.lineTo(10, -18);
                    ctx.lineTo(14, -14);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Bomber details
                    ctx.fillStyle = '#aa66ff';
                    ctx.fillRect(-8, -6, 16, 3);
                    ctx.fillRect(-6, -2, 12, 3);
                    break;
                    
                default:
                    // Default to basic enemy
                    ctx.fillStyle = '#ff4444';
                    ctx.beginPath();
                    ctx.moveTo(0, 16);
                    ctx.lineTo(-12, -12);
                    ctx.lineTo(-8, -16);
                    ctx.lineTo(8, -16);
                    ctx.lineTo(12, -12);
                    ctx.closePath();
                    ctx.fill();
                    break;
            }
            
            ctx.restore();
        }

        function drawPowerup(powerup) {
            ctx.save();
            ctx.translate(powerup.x + powerup.width / 2, powerup.y + powerup.height / 2);
            
            // Simple rotation animation
            const rotation = Math.sin(Date.now() * 0.003) * 0.1;
            ctx.rotate(rotation);
            
            let emoji;
            switch(powerup.type) {
                case 'speed': emoji = '⚡'; break;
                case 'double': emoji = '🚀'; break;
                case 'shield': emoji = '🛡️'; break;
                case 'extraLife': emoji = '❤️'; break;
                case 'starPower': emoji = '⭐'; break;
                case 'fireRate': emoji = '🔥'; break;
                case 'money': emoji = '💰'; break;
                case 'diamond': emoji = '💎'; break;
                case 'bomb': emoji = '💣'; break;
                case 'freeze': emoji = '🧊'; break;
                case 'magnet': emoji = '🧲'; break;
                // Weapon powerups with distinctive emojis
                case 'weaponPlasma': emoji = '🔵'; break;
                case 'weaponSpread': emoji = '🔶'; break;
                case 'weaponLaser': emoji = '🔴'; break;
                case 'weaponMissile': emoji = '🚀'; break;
                case 'weaponLightning': emoji = '⚡'; break;
                case 'weaponIce': emoji = '❄️'; break;
                case 'weaponFire': emoji = '🔥'; break;
                case 'weaponEnergy': emoji = '💚'; break;
                case 'weaponQuantum': emoji = '💜'; break;
                case 'weaponSonic': emoji = '🎵'; break;
                default: emoji = '❓'; break; // Fallback emoji
            }
            
            // Simple pulsing animation for weapon powerups
            if (powerup.isWeapon) {
                const pulse = Math.sin(Date.now() * 0.01) * 0.2 + 1.0;
                ctx.scale(pulse, pulse);
            }
            
                        // Draw emoji with clean appearance
            ctx.font = powerup.isWeapon ? '24px Arial' : '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(emoji, 0, 0);
            
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        function updatePlayer() {
            const ship = ships[currentShip];
            const baseSpeed = playerPower === 'speed' ? 10 : 6; // Increased speed
            const speed = baseSpeed * ship.speed;
            
            // Improved movement with better responsiveness
            if (keys['ArrowLeft'] && player.x > 0) player.x -= speed;
            if (keys['ArrowRight'] && player.x < canvas.width - player.width) player.x += speed;
            if (keys['ArrowUp'] && player.y > 0) player.y -= speed;
            if (keys['ArrowDown'] && player.y < canvas.height - player.height) player.y += speed;
            
            // Optimized shooting with reduced cooldown
            const now = Date.now();
            const currentShotCooldown = shotCooldown / ship.fireRate;
            
            // Weapon-based shooting system
            const weapon = weapons[currentWeapon];
            
            // Handle rapid fire
            if (rapidFireActive && now - lastShot > rapidFireCooldown) {
                // Rapid fire creates bullets more frequently
                const bulletConfig = {
                    x: player.x + player.width / 2 - weapon.bulletSize.width / 2,
                    y: player.y,
                    width: weapon.bulletSize.width,
                    height: weapon.bulletSize.height,
                    speed: weapon.bulletSpeed,
                    color: weapon.color,
                    type: currentWeapon,
                    damage: weapon.damage
                };
                
                bullets.push(bulletConfig);
                playMissileSound();
                lastShot = now;
            } else if (keys['Space'] && now - lastShot > currentShotCooldown) {
                // Create bullets based on current weapon
                const bulletConfig = {
                    x: player.x + player.width / 2 - weapon.bulletSize.width / 2,
                    y: player.y,
                    width: weapon.bulletSize.width,
                    height: weapon.bulletSize.height,
                    speed: weapon.bulletSpeed,
                    color: weapon.color,
                    type: currentWeapon,
                    damage: weapon.damage
                };
                
                if (doubleShot) {
                    // Double shot creates multiple bullets
                    bullets.push({ ...bulletConfig, x: player.x + 5 });
                    bullets.push({ ...bulletConfig, x: player.x + 15 });
                    bullets.push({ ...bulletConfig, x: player.x + 25 });
                    bullets.push({ ...bulletConfig, x: player.x + 35 });
                } else {
                    // Single shot
                    bullets.push(bulletConfig);
                }
                
                // Special weapon effects
                if (currentWeapon === 'spread') {
                    // Spread shot creates diagonal bullets
                    bullets.push({
                        ...bulletConfig,
                        speedX: -2,
                        speedY: -weapon.bulletSpeed
                    });
                    bullets.push({
                        ...bulletConfig,
                        speedX: 2,
                        speedY: -weapon.bulletSpeed
                    });
                }
                
                if (currentWeapon === 'missile') {
                    // Missiles have homing capability
                    bulletConfig.homing = true;
                }
                
                playMissileSound();
                lastShot = now;
            }
            
            // Optimized timer updates
            if (shieldActive && --shieldTimer <= 0) {
                shieldActive = false;
            }
            
            if (starPowerActive && --starPowerTimer <= 0) {
                starPowerActive = false;
            }
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Handle different bullet types
                switch (bullet.type) {
                    case 'spread':
                        // Spread bullets move in diagonal patterns
                        if (bullet.speedX !== undefined && bullet.speedY !== undefined) {
                            bullet.x += bullet.speedX;
                            bullet.y += bullet.speedY;
                        } else {
                            bullet.y -= bullet.speed;
                        }
                        break;
                        
                    case 'missile':
                        // Homing missiles (basic homing behavior)
                        if (bullet.homing && enemies.length > 0) {
                            // Find closest enemy
                            let closestEnemy = null;
                            let closestDistance = Infinity;
                            
                            for (let enemy of enemies) {
                                const distance = Math.sqrt(
                                    Math.pow(bullet.x - enemy.x, 2) + 
                                    Math.pow(bullet.y - enemy.y, 2)
                                );
                                if (distance < closestDistance) {
                                    closestDistance = distance;
                                    closestEnemy = enemy;
                                }
                            }
                            
                            // Move towards closest enemy
                            if (closestEnemy) {
                                const dx = closestEnemy.x - bullet.x;
                                const dy = closestEnemy.y - bullet.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (distance > 0) {
                                    bullet.x += (dx / distance) * bullet.speed * 0.5;
                                    bullet.y += (dy / distance) * bullet.speed * 0.5;
                                }
                            } else {
                                bullet.y -= bullet.speed;
                            }
                        } else {
                            bullet.y -= bullet.speed;
                        }
                        break;
                        
                    case 'lightning':
                        // Lightning bolts move in zigzag pattern
                        bullet.y -= bullet.speed;
                        bullet.x += Math.sin(bullet.y * 0.1) * 2;
                        break;
                        
                    case 'fire':
                        // Fireballs have slight spread
                        bullet.y -= bullet.speed;
                        bullet.x += Math.sin(bullet.y * 0.05) * 1;
                        break;
                        
                    case 'quantum':
                        // Quantum blasts have energy trail effect
                        bullet.y -= bullet.speed;
                        // Add trail effect (handled in rendering)
                        break;
                        
                    case 'sonic':
                        // Sonic waves have wave pattern
                        bullet.y -= bullet.speed;
                        bullet.x += Math.sin(bullet.y * 0.15) * 3;
                        break;
                        
                    default:
                        // Standard bullet movement
                        bullet.y -= bullet.speed;
                        break;
                }
                
                // Remove bullets that go off screen
                if (bullet.y < 0 || bullet.y > canvas.height || 
                    bullet.x < 0 || bullet.x > canvas.width) {
                    bullets.splice(i, 1);
                }
            }
        }

        // Enemy batch spawning system
        let enemyBatchSize = 10;
        let enemyBatchTimer = 0;
        let enemyBatchInterval = 3000; // Spawn batch every 3 seconds
        
        function spawnEnemyBatch() {
            const batchSize = Math.min(enemyBatchSize, 10); // Cap at 10 enemies per batch
            
            for (let i = 0; i < batchSize; i++) {
                // Stagger enemy spawns within the batch
                setTimeout(() => {
                    spawnSingleEnemy();
                }, i * 200); // 200ms delay between each enemy in batch
            }
            
            console.log(`🚀 Enemy batch spawned: ${batchSize} enemies`);
        }
        
        function spawnSingleEnemy() {
            // More enemy types for variety
            const enemyTypes = ['basic', 'fast', 'tank', 'scout', 'bomber'];
            const typeWeights = [0.4, 0.25, 0.15, 0.15, 0.05]; // Probability weights
            
            let selectedType = 'basic';
            const rand = Math.random();
            let cumulativeWeight = 0;
            
            for (let i = 0; i < enemyTypes.length; i++) {
                cumulativeWeight += typeWeights[i];
                if (rand <= cumulativeWeight) {
                    selectedType = enemyTypes[i];
                    break;
                }
            }
            
            const enemy = {
                x: Math.random() * (canvas.width - 40),
                y: -40,
                width: 40,
                height: 40,
                speed: getEnemySpeed(selectedType) * enemySpeedMultiplier,
                type: selectedType,
                lastShot: Date.now(),
                shotCooldown: getEnemyShotCooldown(selectedType),
                health: getEnemyHealth(selectedType)
            };
            enemies.push(enemy);
            // Enemy spawned successfully
        }
        
        function spawnEnemy() {
            // Use batch spawning instead of individual spawning
            const currentTime = Date.now();
            
            if (currentTime - enemyBatchTimer > enemyBatchInterval) {
                spawnEnemyBatch();
                enemyBatchTimer = currentTime;
                
                // Increase batch size and frequency as score increases
                enemyBatchSize = Math.min(15, 10 + Math.floor(score / 500));
                enemyBatchInterval = Math.max(1500, 3000 - (score / 100) * 50);
            }
        }
        
        function getEnemySpeed(type) {
            switch(type) {
                case 'basic': return 2.5 + Math.random() * 2;
                case 'fast': return 5 + Math.random() * 2;
                case 'tank': return 1.5 + Math.random() * 1;
                case 'scout': return 6 + Math.random() * 3;
                case 'bomber': return 3 + Math.random() * 2;
                default: return 2.5 + Math.random() * 2;
            }
        }
        
        function getEnemyShotCooldown(type) {
            switch(type) {
                case 'basic': return 1800;
                case 'fast': return 1200;
                case 'tank': return 2500;
                case 'scout': return 800;
                case 'bomber': return 3000;
                default: return 1800;
            }
        }
        
        function getEnemyHealth(type) {
            switch(type) {
                case 'basic': return 1;
                case 'fast': return 1;
                case 'tank': return 3;
                case 'scout': return 1;
                case 'bomber': return 2;
                default: return 1;
            }
        }
        
        function getEnemyScore(type) {
            switch(type) {
                case 'basic': return 10;
                case 'fast': return 20;
                case 'tank': return 30;
                case 'scout': return 15;
                case 'bomber': return 25;
                default: return 10;
            }
        }

        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                enemies[i].y += enemies[i].speed;
                
                // Enemy shooting - only if enemy is on screen
                if (enemies[i].y > 0 && enemies[i].y < canvas.height) {
                    const now = Date.now();
                    if (now - enemies[i].lastShot > enemies[i].shotCooldown) {
                        const enemyBullet = {
                            x: enemies[i].x + 20,
                            y: enemies[i].y + 40,
                            width: 3,
                            height: 6,
                            speed: 4
                        };
                        enemyBullets.push(enemyBullet);
                        enemies[i].lastShot = now;
                        console.log('Enemy shot fired:', enemyBullet);
                    }
                }
                
                if (enemies[i].y > canvas.height) {
                    enemies.splice(i, 1);
                }
            }
        }

        function updateEnemyBullets() {
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                enemyBullets[i].y += enemyBullets[i].speed;
                if (enemyBullets[i].y > canvas.height) {
                    enemyBullets.splice(i, 1);
                }
            }
        }

        function spawnPowerup() {
            // Increased powerup spawn rates for better visibility
            const weaponSpawnRate = 0.015; // Increased for better balance
            const regularSpawnRate = 0.025; // Increased from 0.012 for more collectibles
            const moneySpawnRate = 0.02; // New dedicated money spawn rate
            const diamondSpawnRate = 0.015; // New dedicated diamond spawn rate
            
            // Limit total powerups on screen to prevent overwhelming
            const maxPowerupsOnScreen = 12; // Increased from 8
            const maxWeaponPowerupsOnScreen = 3;
            
            // Spawn money collectibles more frequently
            if (Math.random() < moneySpawnRate && powerups.filter(p => p.type === 'money').length < 4) {
                powerups.push({
                    x: Math.random() * (canvas.width - 20),
                    y: -20,
                    width: 20,
                    height: 20,
                    speed: 2,
                    type: 'money',
                    isWeapon: false
                });
                console.log(`💰 Money collectible spawned at x: ${powerups[powerups.length - 1].x}`);
            }
            
            // Spawn diamond collectibles more frequently
            if (Math.random() < diamondSpawnRate && powerups.filter(p => p.type === 'diamond').length < 3) {
                powerups.push({
                    x: Math.random() * (canvas.width - 20),
                    y: -20,
                    width: 20,
                    height: 20,
                    speed: 2.5,
                    type: 'diamond',
                    isWeapon: false
                });
                console.log(`💎 Diamond collectible spawned at x: ${powerups[powerups.length - 1].x}`);
            }
            
            if (Math.random() < regularSpawnRate && powerups.filter(p => !p.isWeapon && p.type !== 'money' && p.type !== 'diamond').length < maxPowerupsOnScreen) {
                const regularTypes = ['speed', 'double', 'shield', 'extraLife', 'starPower', 'fireRate', 'rapidFire', 'bomb', 'freeze', 'magnet'];
                const type = regularTypes[Math.floor(Math.random() * regularTypes.length)];
                powerups.push({
                    x: Math.random() * (canvas.width - 20),
                    y: -20,
                    width: 20,
                    height: 20,
                    speed: 2,
                    type: type,
                    isWeapon: false
                });
            }
            
            // Separate weapon powerup spawning with improved logic
            if (Math.random() < weaponSpawnRate && powerups.filter(p => p.isWeapon).length < maxWeaponPowerupsOnScreen) {
                const weaponTypes = ['weaponPlasma', 'weaponSpread', 'weaponLaser', 'weaponMissile', 'weaponLightning', 'weaponIce', 'weaponFire', 'weaponEnergy', 'weaponQuantum', 'weaponSonic'];
                const weaponType = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
                powerups.push({
                    x: Math.random() * (canvas.width - 24),
                    y: -24,
                    width: 24,
                    height: 24,
                    speed: 2.5,
                    type: weaponType,
                    isWeapon: true // Mark as weapon powerup
                });
                console.log(`🔫 Weapon powerup spawned: ${weaponType} at x: ${powerups[powerups.length - 1].x}`);
            }
        }

        function updatePowerups() {
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                
                // Simplified movement for better performance
                powerup.y += powerup.speed;
                
                if (powerup.y > canvas.height) {
                    powerups.splice(i, 1);
                }
            }
        }

        function updateStars() {
            // Optimized star movement for better performance
            for (let i = 0; i < stars.length; i++) {
                stars[i].y += stars[i].speed;
                if (stars[i].y > canvas.height) {
                    stars[i].y = -5;
                    stars[i].x = Math.random() * canvas.width;
                }
            }
        }

        function checkCollisions() {
            // Bullets vs enemies
            for (let i = bullets.length - 1; i >= 0; i--) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (bullets[i].x < enemies[j].x + enemies[j].width &&
                        bullets[i].x + bullets[i].width > enemies[j].x &&
                        bullets[i].y < enemies[j].y + enemies[j].height &&
                        bullets[i].y + bullets[i].height > enemies[j].y) {
                        
                        // Handle special weapon effects
                        const bullet = bullets[i];
                        const enemy = enemies[j];
                        
                        if (enemy.type === 'boss') {
                            // Boss takes damage but doesn't die immediately
                            const damage = bullet.damage || bulletDamage * (bossDamageMultiplier > 1 ? bossDamageMultiplier : 1);
                            enemy.health -= damage;
                            bullets.splice(i, 1);
                            
                            if (enemy.health <= 0) {
                                score += 100; // Boss gives more points
                                enemies.splice(j, 1);
                                bossActive = false;
                                console.log('Boss defeated!');
                            }
                        } else {
                            // Handle special weapon effects
                            if (bullet.type === 'ice' && bullet.slowEffect) {
                                // Ice weapons slow enemies
                                enemy.speed *= 0.7;
                                enemy.speed = Math.max(enemy.speed, 0.5); // Don't slow below 0.5
                            }
                            
                            if (bullet.type === 'fire' && bullet.explosive) {
                                // Fire weapons create area damage
                                const explosionRadius = 60;
                                for (let k = enemies.length - 1; k >= 0; k--) {
                                    const distance = Math.sqrt(
                                        Math.pow(enemy.x - enemies[k].x, 2) + 
                                        Math.pow(enemy.y - enemies[k].y, 2)
                                    );
                                    if (distance < explosionRadius && enemies[k] !== enemy) {
                                        // Damage nearby enemies
                                        const damage = bullet.damage * 0.5;
                                        if (enemies[k].type === 'boss') {
                                            enemies[k].health -= damage;
                                            if (enemies[k].health <= 0) {
                                                score += 100;
                                                enemies.splice(k, 1);
                                                if (k < j) j--; // Adjust index
                                            }
                                        } else {
                                            const baseScore = enemies[k].type === 'fast' ? 20 : 10;
                                            score += baseScore * scoreMultiplier;
                                            enemies.splice(k, 1);
                                            totalEnemiesDestroyed++;
                                            if (k < j) j--; // Adjust index
                                        }
                                    }
                                }
                            }
                            
                            if (bullet.type === 'quantum') {
                                // Quantum weapons have chain reaction
                                const chainRadius = 80;
                                let chainCount = 0;
                                for (let k = enemies.length - 1; k >= 0; k--) {
                                    const distance = Math.sqrt(
                                        Math.pow(enemy.x - enemies[k].x, 2) + 
                                        Math.pow(enemy.y - enemies[k].y, 2)
                                    );
                                    if (distance < chainRadius && enemies[k] !== enemy) {
                                        chainCount++;
                                        const damage = bullet.damage * (1 + chainCount * 0.2);
                                        if (enemies[k].type === 'boss') {
                                            enemies[k].health -= damage;
                                            if (enemies[k].health <= 0) {
                                                score += 100;
                                                enemies.splice(k, 1);
                                                if (k < j) j--;
                                            }
                                        } else {
                                            const baseScore = enemies[k].type === 'fast' ? 20 : 10;
                                            score += baseScore * scoreMultiplier;
                                            enemies.splice(k, 1);
                                            totalEnemiesDestroyed++;
                                            if (k < j) j--;
                                        }
                                    }
                                }
                            }
                            
                            // Regular enemy destruction
                            const baseScore = getEnemyScore(enemy.type);
                            score += baseScore * scoreMultiplier;
                            bullets.splice(i, 1);
                            enemies.splice(j, 1);
                            totalEnemiesDestroyed++;
                            consecutiveHits++;
                            maxConsecutiveHits = Math.max(maxConsecutiveHits, consecutiveHits);
                            updateChallengeProgress('enemies', 1);
                            updateChallengeProgress('consecutive', 1);
                        }
                        break;
                    }
                }
            }

            // Bullets vs enemy bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                for (let j = enemyBullets.length - 1; j >= 0; j--) {
                    if (bullets[i].x < enemyBullets[j].x + enemyBullets[j].width &&
                        bullets[i].x + bullets[i].width > enemyBullets[j].x &&
                        bullets[i].y < enemyBullets[j].y + enemyBullets[j].height &&
                        bullets[i].y + bullets[i].height > enemyBullets[j].y) {
                        // No score for enemy bullets, just remove
                        bullets.splice(i, 1);
                        enemyBullets.splice(j, 1);
                        break;
                    }
                }
            }

            // Player vs enemies
            if (!shieldActive && diamondShield <= 0) {
                for (let i = enemies.length - 1; i >= 0; i--) {
                    if (player.x < enemies[i].x + enemies[i].width &&
                        player.x + player.width > enemies[i].x &&
                        player.y < enemies[i].y + enemies[i].height &&
                        player.y + player.height > enemies[i].y) {
                        lives--;
                        enemies.splice(i, 1);
                        consecutiveHits = 0; // Reset consecutive hits
                        if (lives <= 0) {
                            gameOver();
                        }
                    }
                }
                
                // Player vs enemy bullets
                for (let i = enemyBullets.length - 1; i >= 0; i--) {
                    if (player.x < enemyBullets[i].x + enemyBullets[i].width &&
                        player.x + player.width > enemyBullets[i].x &&
                        player.y < enemyBullets[i].y + enemyBullets[i].height &&
                        player.y + player.height > enemyBullets[i].y) {
                        lives--;
                        enemyBullets.splice(i, 1);
                        consecutiveHits = 0; // Reset consecutive hits
                        if (lives <= 0) {
                            gameOver();
                        }
                    }
                }
            } else if (diamondShield > 0) {
                // Diamond shield blocks hits
                for (let i = enemies.length - 1; i >= 0; i--) {
                    if (player.x < enemies[i].x + enemies[i].width &&
                        player.x + player.width > enemies[i].x &&
                        player.y < enemies[i].y + enemies[i].height &&
                        player.y + player.height > enemies[i].y) {
                        diamondShield--;
                        enemies.splice(i, 1);
                        consecutiveHits = 0;
                        console.log(`Diamond shield blocked hit! ${diamondShield} remaining`);
                    }
                }
                
                for (let i = enemyBullets.length - 1; i >= 0; i--) {
                    if (player.x < enemyBullets[i].x + enemyBullets[i].width &&
                        player.x + player.width > enemyBullets[i].x &&
                        player.y < enemyBullets[i].y + enemyBullets[i].height &&
                        player.y + player.height > enemyBullets[i].y) {
                        diamondShield--;
                        enemyBullets.splice(i, 1);
                        consecutiveHits = 0;
                        console.log(`Diamond shield blocked bullet! ${diamondShield} remaining`);
                    }
                }
            }

            // Player vs powerups
            for (let i = powerups.length - 1; i >= 0; i--) {
                if (player.x < powerups[i].x + powerups[i].width &&
                    player.x + player.width > powerups[i].x &&
                    player.y < powerups[i].y + powerups[i].height &&
                    player.y + player.height > powerups[i].y) {
                    console.log(`🎁 Powerup collected: ${powerups[i].type}`);
                    collectPowerup(powerups[i].type);
                    powerups.splice(i, 1);
                    totalPowerupsCollected++;
                    updateChallengeProgress('powerups', 1);
                }
            }
        }

        function collectPowerup(type) {
            console.log(`🎁 Collecting powerup: ${type}`);
            switch(type) {
                case 'speed':
                    playerPower = 'speed';
                    setTimeout(() => playerPower = 'basic', 10000);
                    break;
                case 'double':
                    doubleShot = true;
                    setTimeout(() => doubleShot = false, 15000);
                    break;
                case 'shield':
                    shieldActive = true;
                    shieldTimer = 300;
                    break;
                case 'extraLife':
                    lives++;
                    break;
                case 'starPower':
                    starPowerActive = true;
                    starPowerTimer = 400;
                    break;
                case 'fireRate':
                    fireRateBoost = true;
                    shotCooldown = 100;
                    setTimeout(() => {
                        fireRateBoost = false;
                        shotCooldown = 200;
                    }, 12000);
                    break;
                case 'money':
                    money += 1;
                    totalMoneyCollected++;
                    updateChallengeProgress('collect_money', 1);
                    break;
                case 'diamond':
                    diamonds += 1;
                    totalDiamondsCollected++;
                    updateChallengeProgress('collect_diamonds', 1);
                    console.log(`💎 Diamond collected! Total: ${totalDiamondsCollected}, Current diamonds: ${diamonds}`);
                    break;
                case 'bomb':
                    // Destroy all enemies on screen
                    const enemiesDestroyed = enemies.length;
                    enemies.splice(0, enemies.length);
                    score += enemiesDestroyed * 10;
                    totalEnemiesDestroyed += enemiesDestroyed;
                    showWeaponSwitchMessage('💣 Bomb! All enemies destroyed!');
                    console.log(`💣 Bomb powerup collected! Destroyed ${enemiesDestroyed} enemies`);
                    break;
                case 'freeze':
                    // Freeze all enemies for 5 seconds
                    enemies.forEach(enemy => {
                        enemy.frozen = true;
                        enemy.originalSpeed = enemy.speed;
                        enemy.speed = 0;
                    });
                    setTimeout(() => {
                        enemies.forEach(enemy => {
                            if (enemy.frozen) {
                                enemy.speed = enemy.originalSpeed;
                                enemy.frozen = false;
                            }
                        });
                    }, 5000);
                    showWeaponSwitchMessage('🧊 Freeze! Enemies stopped for 5s');
                    console.log(`🧊 Freeze powerup collected! Enemies frozen for 5 seconds`);
                    break;
                case 'magnet':
                    // Attract all powerups to player for 10 seconds
                    player.magnetActive = true;
                    setTimeout(() => {
                        player.magnetActive = false;
                    }, 10000);
                    showWeaponSwitchMessage('🧲 Magnet! Powerups attracted for 10s');
                    console.log(`🧲 Magnet powerup collected! Powerups attracted for 10 seconds`);
                    break;
                case 'rapidFire':
                    // Enable rapid fire for 15 seconds
                    rapidFireActive = true;
                    rapidFireTimer = 15000;
                    showWeaponSwitchMessage('⚡ Rapid Fire! 15s');
                    console.log(`⚡ Rapid Fire powerup collected! Rapid fire active for 15 seconds`);
                    break;
                // Weapon powerups - Enhanced with better feedback
                case 'weaponPlasma':
                    console.log(`🔫 Switching to Plasma Cannon from ${currentWeapon}`);
                    const previousWeapon = currentWeapon;
                    currentWeapon = 'plasma';
                    showWeaponSwitchMessage('🔵 Plasma Cannon - 30s');
                    setTimeout(() => {
                        currentWeapon = previousWeapon;
                        showWeaponSwitchMessage(`Back to ${weapons[previousWeapon].name}`);
                        console.log(`🔫 Switched back to ${weapons[previousWeapon].name}`);
                    }, 30000); // 30 seconds
                    console.log(`🔫 Collected Plasma Cannon powerup! Current weapon: ${currentWeapon}`);
                    break;
                case 'weaponSpread':
                    console.log(`🔫 Switching to Spread Shot from ${currentWeapon}`);
                    const prevWeapon = currentWeapon;
                    currentWeapon = 'spread';
                    showWeaponSwitchMessage('🔶 Spread Shot - 30s');
                    setTimeout(() => {
                        currentWeapon = prevWeapon;
                        showWeaponSwitchMessage(`Back to ${weapons[prevWeapon].name}`);
                        console.log(`🔫 Switched back to ${weapons[prevWeapon].name}`);
                    }, 30000);
                    console.log(`🔫 Collected Spread Shot powerup! Current weapon: ${currentWeapon}`);
                    break;
                case 'weaponLaser':
                    console.log(`🔫 Switching to Laser Beam from ${currentWeapon}`);
                    const prevWeapon2 = currentWeapon;
                    currentWeapon = 'laser';
                    showWeaponSwitchMessage('🔴 Laser Beam - 30s');
                    setTimeout(() => {
                        currentWeapon = prevWeapon2;
                        showWeaponSwitchMessage(`Back to ${weapons[prevWeapon2].name}`);
                        console.log(`🔫 Switched back to ${weapons[prevWeapon2].name}`);
                    }, 30000);
                    console.log(`🔫 Collected Laser Beam powerup! Current weapon: ${currentWeapon}`);
                    break;
                case 'weaponMissile':
                    console.log(`🔫 Switching to Homing Missile from ${currentWeapon}`);
                    const prevWeapon3 = currentWeapon;
                    currentWeapon = 'missile';
                    showWeaponSwitchMessage('🚀 Homing Missile - 30s');
                    setTimeout(() => {
                        currentWeapon = prevWeapon3;
                        showWeaponSwitchMessage(`Back to ${weapons[prevWeapon3].name}`);
                        console.log(`🔫 Switched back to ${weapons[prevWeapon3].name}`);
                    }, 30000);
                    console.log(`🔫 Collected Homing Missile powerup! Current weapon: ${currentWeapon}`);
                    break;
                case 'weaponLightning':
                    console.log(`🔫 Switching to Lightning Bolt from ${currentWeapon}`);
                    const prevWeapon4 = currentWeapon;
                    currentWeapon = 'lightning';
                    showWeaponSwitchMessage('⚡ Lightning Bolt - 30s');
                    setTimeout(() => {
                        currentWeapon = prevWeapon4;
                        showWeaponSwitchMessage(`Back to ${weapons[prevWeapon4].name}`);
                        console.log(`🔫 Switched back to ${weapons[prevWeapon4].name}`);
                    }, 30000);
                    console.log(`🔫 Collected Lightning Bolt powerup! Current weapon: ${currentWeapon}`);
                    break;
                case 'weaponIce':
                    console.log(`🔫 Switching to Ice Shard from ${currentWeapon}`);
                    const prevWeapon5 = currentWeapon;
                    currentWeapon = 'ice';
                    showWeaponSwitchMessage('❄️ Ice Shard - 30s');
                    setTimeout(() => {
                        currentWeapon = prevWeapon5;
                        showWeaponSwitchMessage(`Back to ${weapons[prevWeapon5].name}`);
                        console.log(`🔫 Switched back to ${weapons[prevWeapon5].name}`);
                    }, 30000);
                    console.log(`🔫 Collected Ice Shard powerup! Current weapon: ${currentWeapon}`);
                    break;
                case 'weaponFire':
                    console.log(`🔫 Switching to Fireball from ${currentWeapon}`);
                    const prevWeapon6 = currentWeapon;
                    currentWeapon = 'fire';
                    showWeaponSwitchMessage('🔥 Fireball - 30s');
                    setTimeout(() => {
                        currentWeapon = prevWeapon6;
                        showWeaponSwitchMessage(`Back to ${weapons[prevWeapon6].name}`);
                        console.log(`🔫 Switched back to ${weapons[prevWeapon6].name}`);
                    }, 30000);
                    console.log(`🔫 Collected Fireball powerup! Current weapon: ${currentWeapon}`);
                    break;
                case 'weaponEnergy':
                    console.log(`🔫 Switching to Energy Pulse from ${currentWeapon}`);
                    const prevWeapon7 = currentWeapon;
                    currentWeapon = 'energy';
                    showWeaponSwitchMessage('💚 Energy Pulse - 30s');
                    setTimeout(() => {
                        currentWeapon = prevWeapon7;
                        showWeaponSwitchMessage(`Back to ${weapons[prevWeapon7].name}`);
                        console.log(`🔫 Switched back to ${weapons[prevWeapon7].name}`);
                    }, 30000);
                    console.log(`🔫 Collected Energy Pulse powerup! Current weapon: ${currentWeapon}`);
                    break;
                case 'weaponQuantum':
                    console.log(`🔫 Switching to Quantum Blaster from ${currentWeapon}`);
                    const prevWeapon8 = currentWeapon;
                    currentWeapon = 'quantum';
                    showWeaponSwitchMessage('💜 Quantum Blaster - 30s');
                    setTimeout(() => {
                        currentWeapon = prevWeapon8;
                        showWeaponSwitchMessage(`Back to ${weapons[prevWeapon8].name}`);
                        console.log(`🔫 Switched back to ${weapons[prevWeapon8].name}`);
                    }, 30000);
                    console.log(`🔫 Collected Quantum Blaster powerup! Current weapon: ${currentWeapon}`);
                    break;
                case 'weaponSonic':
                    console.log(`🔫 Switching to Sonic Wave from ${currentWeapon}`);
                    const prevWeapon9 = currentWeapon;
                    currentWeapon = 'sonic';
                    showWeaponSwitchMessage('🎵 Sonic Wave - 30s');
                    setTimeout(() => {
                        currentWeapon = prevWeapon9;
                        showWeaponSwitchMessage(`Back to ${weapons[prevWeapon9].name}`);
                        console.log(`🔫 Switched back to ${weapons[prevWeapon9].name}`);
                    }, 30000);
                    console.log(`🔫 Collected Sonic Wave powerup! Current weapon: ${currentWeapon}`);
                    break;
                default:
                    console.log(`❓ Unknown powerup type: ${type}`);
                    break;
            }
        }

        function activatePowerup() {
            if (playerPower === 'basic') return;
            // Additional power-up activation logic can be added here
        }

        function gameOver() {
            gameRunning = false;
            
            // Track game over event with detailed stats
            if (window.firebaseFunctions) {
                window.firebaseFunctions.trackEvent('game_over', {
                    final_score: score,
                    lives_remaining: lives,
                    enemies_destroyed: totalEnemiesDestroyed,
                    powerups_collected: totalPowerupsCollected,
                    diamonds_collected: totalDiamondsCollected,
                    money_collected: totalMoneyCollected,
                    consecutive_hits: maxConsecutiveHits,
                    survival_time: survivalTime,
                    weapon_used: currentWeapon,
                    ship_used: currentShip
                });
                
                // Save detailed game stats
                window.firebaseFunctions.saveGameStats({
                    final_score: score,
                    lives_remaining: lives,
                    enemies_destroyed: totalEnemiesDestroyed,
                    powerups_collected: totalPowerupsCollected,
                    diamonds_collected: totalDiamondsCollected,
                    money_collected: totalMoneyCollected,
                    consecutive_hits: maxConsecutiveHits,
                    survival_time: survivalTime,
                    weapon_used: currentWeapon,
                    ship_used: currentShip,
                    max_consecutive_hits: maxConsecutiveHits
                });
            }
            
            saveHighScores();
            
            // Check for medal qualification
            const medalInfo = checkMedalQualification();
            
            if (medalInfo) {
                // Show medal modal instead of regular game over
                showMedalModal(medalInfo);
            } else {
                // Regular game over
                alert(`Game Over!\nFinal Score: ${score}\n${score > highScore ? '🎉 NEW HIGH SCORE! 🎉' : ''}`);
                backToMenu();
            }
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#000033';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            ctx.fillStyle = 'white';
            stars.forEach(star => {
                ctx.fillRect(star.x, star.y, 1, 1);
            });

            // Draw powerups
            powerups.forEach(powerup => {
                drawPowerup(powerup);
            });

            // Draw enemies
            enemies.forEach(enemy => {
                if (enemy.type === 'boss') {
                    drawBoss(enemy.x, enemy.y, enemy.health, bossMaxHealth);
                } else {
                    drawEnemyShip(enemy.x, enemy.y, enemy.type);
                }
            });

            // Draw bullets
            bullets.forEach(bullet => {
                ctx.save();
                
                // Set color based on bullet type
                if (bullet.color) {
                    ctx.fillStyle = bullet.color;
                } else {
                    ctx.fillStyle = '#ffd700'; // Default gold color
                }
                
                // Handle different bullet types with optimized performance
                switch (bullet.type) {
                    case 'plasma':
                        // Plasma bolts with minimal glow
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 5;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        break;
                        
                    case 'laser':
                        // Laser beam with simple trail
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // Add simple laser trail
                        ctx.globalAlpha = 0.4;
                        ctx.fillRect(bullet.x, bullet.y + bullet.height, bullet.width, bullet.height);
                        break;
                        
                    case 'missile':
                        // Missiles with simple trail
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // Add simple rocket trail
                        ctx.fillStyle = '#ff8800';
                        ctx.globalAlpha = 0.6;
                        ctx.fillRect(bullet.x + 2, bullet.y + bullet.height, bullet.width - 4, bullet.height/2);
                        break;
                        
                    case 'lightning':
                        // Lightning bolts with minimal effect
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 4;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        break;
                        
                    case 'ice':
                        // Ice shards with simple crystals
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // Add simple ice crystals
                        ctx.fillStyle = '#ffffff';
                        ctx.globalAlpha = 0.6;
                        ctx.fillRect(bullet.x + 1, bullet.y + 2, 2, 2);
                        break;
                        
                    case 'fire':
                        // Fireballs with simple flame
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // Add simple flame trail
                        ctx.fillStyle = '#ff6600';
                        ctx.globalAlpha = 0.5;
                        ctx.fillRect(bullet.x + 1, bullet.y + bullet.height, bullet.width - 2, bullet.height/2);
                        break;
                        
                    case 'energy':
                        // Energy pulses with minimal effect
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 3;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        break;
                        
                    case 'quantum':
                        // Quantum blasts with simple trail
                        ctx.shadowColor = bullet.color;
                        ctx.shadowBlur = 8;
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // Add simple quantum trail
                        ctx.globalAlpha = 0.4;
                        ctx.fillRect(bullet.x, bullet.y + bullet.height, bullet.width, bullet.height);
                        break;
                        
                    case 'sonic':
                        // Sonic waves with simple effect
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        // Add simple sonic waves
                        ctx.globalAlpha = 0.3;
                        ctx.fillRect(bullet.x - 2, bullet.y + bullet.height/2, bullet.width + 4, 1);
                        break;
                        
                    default:
                        // Standard bullets
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                        break;
                }
                
                ctx.restore();
            });

            // Draw enemy bullets
            ctx.fillStyle = '#ff0000'; // Red for enemy bullets
            enemyBullets.forEach(bullet => {
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });

            // Draw player
            drawPlayerShip();

            // Update score display
            let powerText = 'Basic';
            if (playerPower === 'speed') powerText = 'Speed Boost';
            if (doubleShot) powerText += ' + Double Shot';
            if (shieldActive) powerText += ' + Shield';
            if (starPowerActive) powerText += ' + Star Power';
            if (fireRateBoost) powerText += ' + Fire Rate';
            
            scoreDisplay.innerHTML = `
                <span>Score: ${score}</span>
                <span>Lives: ${lives}</span>
                <span>Kills: ${totalEnemiesDestroyed}</span>
            `;
            
            // Draw weapon info
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 10, 200, 60);
            ctx.fillStyle = '#ffffff';
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Weapon: ${weapons[currentWeapon].name}`, 20, 30);
            ctx.fillText(`Damage: ${weapons[currentWeapon].damage * bulletDamage}`, 20, 45);
            ctx.fillText(`Fire Rate: ${(weapons[currentWeapon].fireRate * 100).toFixed(0)}%`, 20, 60);
            
            // Draw weapon controls hint
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(canvas.width - 250, 10, 240, 80);
            ctx.fillStyle = '#ffff00';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Weapon Controls:', canvas.width - 240, 25);
            ctx.fillStyle = '#ffffff';
            ctx.fillText('1-0: Switch weapons', canvas.width - 240, 40);
            ctx.fillText('-: Sonic Wave', canvas.width - 240, 55);
            ctx.fillText('Space: Shoot', canvas.width - 240, 70);
            
            // Update stats display
            updateStatsDisplay();
            
            // Draw current challenge
            if (challengeActive && currentChallenge && challengeTimer > 0) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(10, 80, 300, 60);
                ctx.fillStyle = '#ffff00';
                ctx.font = '16px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`Challenge: ${currentChallenge.name}`, 20, 100);
                ctx.fillStyle = '#ffffff';
                ctx.font = '14px Arial';
                ctx.fillText(`${currentChallenge.description}`, 20, 120);
                ctx.fillText(`Progress: ${challengeProgress}/${challengeTarget}`, 20, 135);
                challengeTimer--;
            }
            
            // Draw challenge completion message
            if (challengeCompleteMessage && challengeCompleteTimer > 0) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#00ff00';
                ctx.font = '36px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(challengeCompleteMessage, canvas.width / 2, canvas.height / 2);

                challengeCompleteTimer--;
                if (challengeCompleteTimer <= 0) {
                    challengeCompleteMessage = '';
                }
            }

            // Draw weapon indicator
            if (gameRunning) {
                const weapon = weapons[currentWeapon];
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(10, 60, 200, 40);
                ctx.fillStyle = weapon.color;
                ctx.font = '16px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`🔫 ${weapon.name}`, 20, 80);
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Arial';
                ctx.fillText(`Damage: ${weapon.damage}x | Fire Rate: ${weapon.fireRate}x`, 20, 95);
            }
        }

        function gameLoop() {
            if (!gameRunning) {
                console.log('Game not running, exiting gameLoop');
                return;
            }
            
            if (gamePaused) {
                showPauseMessage();
                requestAnimationFrame(gameLoop);
                return;
            }

            const currentTime = Date.now();
            survivalTime = Math.floor((currentTime - startTime) / 1000);
            
            // Optimized update frequency - only update time-based features every 100ms
            if (currentTime % 100 < 16) {
                // Update time-based challenges (only every second)
                if (currentTime % 1000 < 16) {
                    updateChallengeProgress('time', survivalTime);
                }
                
                // Update store system timers (optimized)
                if (scoreMultiplierTimer > 0) {
                    scoreMultiplierTimer -= 16;
                    if (scoreMultiplierTimer <= 0) {
                        scoreMultiplier = 1;
                    }
                }
                
                if (bossDamageTimer > 0) {
                    bossDamageTimer -= 16;
                    if (bossDamageTimer <= 0) {
                        bossDamageMultiplier = 1;
                    }
                }
                
                if (diamondStormTimer > 0) {
                    diamondStormTimer -= 16;
                    if (diamondStormTimer <= 0) {
                        diamondStormActive = false;
                    }
                }
                
                // Update rapid fire timer
                if (rapidFireTimer > 0) {
                    rapidFireTimer -= 16;
                    if (rapidFireTimer <= 0) {
                        rapidFireActive = false;
                        console.log('⚡ Rapid Fire deactivated');
                    }
                }
            }

            // Core game updates - optimized order for better performance
            updateStars();
            updatePlayer();
            updateBullets();
            updateEnemyBullets();
            
            // Spawn enemies and powerups less frequently for better performance
            if (currentTime % 50 < 16) {
                spawnEnemy();
            }
            if (currentTime % 100 < 16) {
                spawnPowerup();
            }
            
            updateEnemies();
            updatePowerups();
            checkCollisions();
            
            // Update difficulty less frequently
            if (currentTime % 5000 < 16) {
                updateDifficulty();
            }
            
            draw();

            requestAnimationFrame(gameLoop);
        }

        // Load high scores from localStorage
        function loadHighScores() {
            try {
                const savedHighScore = localStorage.getItem('kadenAdelynnHighScore');
                if (savedHighScore) highScore = parseInt(savedHighScore);
                console.log('Loaded high scores:', { highScore });
            } catch (error) {
                console.log('Error loading high scores:', error);
            }
        }
        
        // Save high scores to localStorage
        function saveHighScores() {
            const scores = JSON.parse(localStorage.getItem('highScores') || '[]');
            scores.push(score);
            scores.sort((a, b) => b - a);
            scores.splice(10); // Keep only top 10
            localStorage.setItem('highScores', JSON.stringify(scores));
            highScore = scores[0] || 0;
            
            // Save to Firebase if available
            if (window.firebaseFunctions) {
                window.firebaseFunctions.saveHighScore(score, 'Player');
                window.firebaseFunctions.trackEvent('game_completed', {
                    score: score,
                    lives_remaining: lives,
                    enemies_destroyed: totalEnemiesDestroyed,
                    survival_time: survivalTime,
                    weapon_used: currentWeapon
                });
            }
        }

        // Medal System Functions
        function loadLeaderboard() {
            try {
                const savedLeaderboard = localStorage.getItem('kadenAdelynnTop3');
                if (savedLeaderboard) {
                    top3Leaderboard = JSON.parse(savedLeaderboard);
                }
                updateLeaderboardDisplay();
                console.log('Loaded leaderboard:', top3Leaderboard);
            } catch (error) {
                console.log('Error loading leaderboard:', error);
            }
        }

        function saveLeaderboard() {
            try {
                localStorage.setItem('kadenAdelynnTop3', JSON.stringify(top3Leaderboard));
                updateLeaderboardDisplay();
                console.log('Saved leaderboard:', top3Leaderboard);
            } catch (error) {
                console.log('Error saving leaderboard:', error);
            }
        }

        function checkMedalQualification() {
            const currentDate = new Date().toISOString().split('T')[0];
            let medalEarned = null;
            let newRank = null;

            // Check if score qualifies for any medal (minimum 500 points)
            if (score < 500) return null;

            // Check for Gold Medal
            if (score > top3Leaderboard.gold.score) {
                medalEarned = 'gold';
                newRank = 1;
                // Shift existing medals down
                top3Leaderboard.bronze = { ...top3Leaderboard.silver };
                top3Leaderboard.silver = { ...top3Leaderboard.gold };
                top3Leaderboard.gold = { name: '', score: score, date: currentDate };
            }
            // Check for Silver Medal
            else if (score > top3Leaderboard.silver.score) {
                medalEarned = 'silver';
                newRank = 2;
                // Shift bronze down
                top3Leaderboard.bronze = { ...top3Leaderboard.silver };
                top3Leaderboard.silver = { name: '', score: score, date: currentDate };
            }
            // Check for Bronze Medal
            else if (score > top3Leaderboard.bronze.score) {
                medalEarned = 'bronze';
                newRank = 3;
                top3Leaderboard.bronze = { name: '', score: score, date: currentDate };
            }

            if (medalEarned) {
                currentMedal = { type: medalEarned, rank: newRank };
                return { medal: medalEarned, rank: newRank };
            }

            return null;
        }

        function showMedalModal(medalInfo) {
            const modal = document.getElementById('medalModal');
            const title = document.getElementById('medalTitle');
            const icon = document.getElementById('medalIcon');
            const message = document.getElementById('medalMessage');
            const scoreSpan = document.getElementById('medalScore');
            const rankSpan = document.getElementById('medalRank');
            const nameInput = document.getElementById('playerName');

            // Set medal-specific content
            if (medalInfo.medal === 'gold') {
                title.textContent = '🥇 NEW GOLD CHAMPION! 🥇';
                icon.textContent = '🥇';
                message.textContent = 'You have claimed the throne!';
                rankSpan.textContent = '#1';
            } else if (medalInfo.medal === 'silver') {
                title.textContent = '🥈 SILVER MEDAL! 🥈';
                icon.textContent = '🥈';
                message.textContent = 'You take second place!';
                rankSpan.textContent = '#2';
            } else if (medalInfo.medal === 'bronze') {
                title.textContent = '🥉 BRONZE MEDAL! 🥉';
                icon.textContent = '🥉';
                message.textContent = 'You earn third place!';
                rankSpan.textContent = '#3';
            }

            scoreSpan.textContent = score;
            nameInput.value = '';
            nameInput.focus();
            modal.style.display = 'flex';
            medalModalOpen = true;
        }

        function claimMedal() {
            const nameInput = document.getElementById('playerName');
            const playerName = nameInput.value.trim();

            if (!playerName) {
                alert('Please enter your name to claim your medal!');
                return;
            }

            if (playerName.length > 15) {
                alert('Name must be 15 characters or less!');
                return;
            }

            // Update the leaderboard with the player's name
            if (currentMedal && currentMedal.type) {
                const currentDate = new Date().toISOString().split('T')[0];
                
                if (currentMedal.type === 'gold') {
                    top3Leaderboard.gold.name = playerName;
                } else if (currentMedal.type === 'silver') {
                    top3Leaderboard.silver.name = playerName;
                } else if (currentMedal.type === 'bronze') {
                    top3Leaderboard.bronze.name = playerName;
                }

                saveLeaderboard();
                closeMedalModal();
                
                // Show celebration message
                setTimeout(() => {
                    alert(`🏅 Congratulations ${playerName}! Your medal has been claimed! 🏅`);
                }, 100);
            }
        }

        function skipMedal() {
            // If player skips, still save the score but with default name
            if (currentMedal && currentMedal.type) {
                const currentDate = new Date().toISOString().split('T')[0];
                
                if (currentMedal.type === 'gold') {
                    top3Leaderboard.gold.name = 'Champion';
                } else if (currentMedal.type === 'silver') {
                    top3Leaderboard.silver.name = 'Runner';
                } else if (currentMedal.type === 'bronze') {
                    top3Leaderboard.bronze.name = 'Player';
                }

                saveLeaderboard();
            }
            
            closeMedalModal();
        }

        function closeMedalModal() {
            const modal = document.getElementById('medalModal');
            modal.style.display = 'none';
            medalModalOpen = false;
            currentMedal = null;
        }

        function updateLeaderboardDisplay() {
            const leaderboardDisplay = document.getElementById('leaderboardDisplay');
            if (!leaderboardDisplay) return;

            const entries = leaderboardDisplay.children;
            
            // Update Gold
            if (entries[0]) {
                const goldInfo = entries[0].querySelector('.medal-info');
                if (goldInfo) {
                    goldInfo.querySelector('.medal-name').textContent = top3Leaderboard.gold.name;
                    goldInfo.querySelector('.medal-score').textContent = `${top3Leaderboard.gold.score} points`;
                    const dateText = top3Leaderboard.gold.score > 0 ? `Crowned: ${top3Leaderboard.gold.date}` : 'Crowned: Never';
                    goldInfo.querySelector('.medal-date').textContent = dateText;
                }
            }

            // Update Silver
            if (entries[1]) {
                const silverInfo = entries[1].querySelector('.medal-info');
                if (silverInfo) {
                    silverInfo.querySelector('.medal-name').textContent = top3Leaderboard.silver.name;
                    silverInfo.querySelector('.medal-score').textContent = `${top3Leaderboard.silver.score} points`;
                    const dateText = top3Leaderboard.silver.score > 0 ? `Achieved: ${top3Leaderboard.silver.date}` : 'Achieved: Never';
                    silverInfo.querySelector('.medal-date').textContent = dateText;
                }
            }

            // Update Bronze
            if (entries[2]) {
                const bronzeInfo = entries[2].querySelector('.medal-info');
                if (bronzeInfo) {
                    bronzeInfo.querySelector('.medal-name').textContent = top3Leaderboard.bronze.name;
                    bronzeInfo.querySelector('.medal-score').textContent = `${top3Leaderboard.bronze.score} points`;
                    const dateText = top3Leaderboard.bronze.score > 0 ? `Earned: ${top3Leaderboard.bronze.date}` : 'Earned: Never';
                    bronzeInfo.querySelector('.medal-date').textContent = dateText;
                }
            }
        }
        
        // Dynamic difficulty scaling based on score
        function updateDifficulty() {
            // Increase spawn rate based on score (more aggressive scaling)
            enemySpawnRate = Math.min(0.12, 0.06 + (score / 400) * 0.015);
            
            // Increase enemy speed based on score (more aggressive scaling)
            enemySpeedMultiplier = Math.min(2.5, 1.2 + (score / 400) * 0.3);
            
            // Spawn boss every 500 points
            if (score > 0 && score % 500 === 0 && !bossActive) {
                spawnBoss();
            }
        }
        
        function spawnBoss() {
            bossActive = true;
            bossMaxHealth = Math.floor(score / 100) + 10; // Boss health scales with score
            bossHealth = bossMaxHealth;
            
            const boss = {
                x: canvas.width / 2 - 40,
                y: -80,
                width: 80,
                height: 80,
                speed: 1,
                type: 'boss',
                lastShot: Date.now(),
                shotCooldown: 1000,
                health: bossHealth
            };
            enemies.push(boss);
            console.log('Boss spawned:', boss);
        }
        
        function drawBoss(x, y, health, maxHealth) {
            ctx.save();
            ctx.translate(x + 40, y + 40);
            
            // Boss body
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.moveTo(0, -30);
            ctx.lineTo(-25, 20);
            ctx.lineTo(-15, 30);
            ctx.lineTo(15, 30);
            ctx.lineTo(25, 20);
            ctx.closePath();
            ctx.fill();
            
            // Boss details
            ctx.fillStyle = '#ff6666';
            ctx.fillRect(-20, 10, 40, 8);
            ctx.fillRect(-15, 20, 30, 6);
            
            // Health bar
            const healthBarWidth = 60;
            const healthBarHeight = 6;
            const healthPercentage = health / maxHealth;
            
            ctx.fillStyle = '#333333';
            ctx.fillRect(-healthBarWidth/2, -45, healthBarWidth, healthBarHeight);
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(-healthBarWidth/2, -45, healthBarWidth * healthPercentage, healthBarHeight);
            
            ctx.restore();
        }

        // Challenge system
        function initializeChallenges() {
            challenges = [
                { id: 'collect_diamonds', name: 'Diamond Hunter', description: 'Collect 10 diamonds', target: 10, reward: 50, type: 'diamonds' },
                { id: 'destroy_enemies', name: 'Enemy Destroyer', description: 'Destroy 20 enemies', target: 20, reward: 30, type: 'enemies' },
                { id: 'survive_time', name: 'Survivor', description: 'Survive for 2 minutes', target: 120, reward: 40, type: 'time' },
                { id: 'consecutive_hits', name: 'Sharpshooter', description: 'Hit 5 enemies in a row', target: 5, reward: 25, type: 'consecutive' },
                { id: 'collect_powerups', name: 'Power Collector', description: 'Collect 8 power-ups', target: 8, reward: 35, type: 'powerups' },
                { id: 'reach_score', name: 'Score Master', description: 'Reach 500 points', target: 500, reward: 60, type: 'score' },
                { id: 'defeat_boss', name: 'Boss Slayer', description: 'Defeat a boss', target: 1, reward: 100, type: 'boss' },
                { id: 'collect_money', name: 'Money Collector', description: 'Collect 15 money items', target: 15, reward: 45, type: 'money' }
            ];
        }
        
        function startRandomChallenge() {
            if (challengeActive) return;
            
            const availableChallenges = challenges.filter(c => !c.completed);
            if (availableChallenges.length === 0) {
                // Reset all challenges if all completed
                challenges.forEach(c => c.completed = false);
                return startRandomChallenge();
            }
            
            const randomIndex = Math.floor(Math.random() * availableChallenges.length);
            currentChallenge = availableChallenges[randomIndex];
            challengeProgress = 0;
            challengeTarget = currentChallenge.target;
            challengeReward = currentChallenge.reward;
            challengeActive = true;
            challengeTimer = 600; // 10 seconds to show challenge
            
            console.log('New challenge started:', currentChallenge.name);
        }
        
        function updateChallengeProgress(type, amount = 1) {
            if (!challengeActive || !currentChallenge) return;
            
            if (currentChallenge.type === type) {
                if (type === 'time') {
                    // For time-based challenges, check if survival time meets target
                    if (survivalTime >= currentChallenge.target) {
                        completeChallenge();
                    }
                } else if (type === 'consecutive') {
                    // For consecutive hits, check if the challenge is completed
                    if (amount >= currentChallenge.target) {
                        completeChallenge();
                    }
                } else if (type === 'score') {
                    // For score-based challenges, check if score meets target
                    if (score >= currentChallenge.target) {
                        completeChallenge();
                    }
                } else {
                    // For other challenges, accumulate progress
                    challengeProgress += amount;
                    if (challengeProgress >= challengeTarget) {
                        completeChallenge();
                    }
                }
            }
        }
        
        function completeChallenge() {
            if (!challengeActive || !currentChallenge) return;
            
            score += challengeReward;
            currentChallenge.completed = true;
            challengeActive = false;
            
            // Show completion message
            showChallengeComplete(currentChallenge.name, challengeReward);
            
            console.log('Challenge completed:', currentChallenge.name, 'Reward:', challengeReward);
            
            // Start new challenge after a delay
            setTimeout(() => {
                startRandomChallenge();
            }, 3000);
        }
        
        function showChallengeComplete(challengeName, reward) {
            challengeCompleteMessage = `${challengeName} Complete! +${reward} points`;
            challengeCompleteTimer = 180; // 3 seconds
        }

        // Store functions
        function openStore() {
            storeOpen = true;
            document.getElementById('store').style.display = 'block';
            gameUI.style.display = 'none'; // Hide game UI when store is open
        }

        function closeStore() {
            storeOpen = false;
            document.getElementById('store').style.display = 'none';
            gameUI.style.display = 'block'; // Show game UI when store is closed
        }

        function buyExtraLife() {
            if (money >= 50) {
                lives++;
                money -= 50;
                updateChallengeProgress('collect_money', -1); // Deduct money for purchase
                updateChallengeProgress('extraLife', 1); // Track powerup collection
                console.log('Extra life purchased!');
                updateStatsDisplay();
            } else {
                alert('Not enough money!');
            }
        }

        function buyScoreMultiplier() {
            if (money >= 30) {
                scoreMultiplier = 2;
                scoreMultiplierTimer = 30000; // 30 seconds
                money -= 30;
                updateChallengeProgress('collect_money', -1);
                updateChallengeProgress('scoreMultiplier', 1);
                console.log('Score multiplier purchased!');
                updateStatsDisplay();
            } else {
                alert('Not enough money!');
            }
        }

        function buyShieldRecharge() {
            if (money >= 25) {
                shieldActive = true;
                shieldTimer = 300;
                money -= 25;
                updateChallengeProgress('collect_money', -1);
                updateChallengeProgress('shieldRecharge', 1);
                console.log('Shield recharge purchased!');
                updateStatsDisplay();
            } else {
                alert('Not enough money!');
            }
        }

        function buyEmergencyBoost() {
            if (money >= 20) {
                playerPower = 'speed';
                doubleShot = true;
                fireRateBoost = true;
                shotCooldown = 100;
                setTimeout(() => {
                    playerPower = 'basic';
                    doubleShot = false;
                    fireRateBoost = false;
                    shotCooldown = 200;
                }, 12000);
                money -= 20;
                updateChallengeProgress('collect_money', -1);
                updateChallengeProgress('emergencyBoost', 1);
                console.log('Emergency boost purchased!');
                updateStatsDisplay();
            } else {
                alert('Not enough money!');
            }
        }

        function buyBulletDamage() {
            if (diamonds >= 5) {
                bulletDamage++;
                diamonds -= 5;
                updateChallengeProgress('collect_diamonds', -1);
                updateChallengeProgress('bulletDamage', 1);
                console.log('Bullet damage upgrade purchased!');
                updateStatsDisplay();
            } else {
                alert('Not enough diamonds!');
            }
        }

        function buyBossWeakness() {
            if (diamonds >= 3) {
                bossDamageMultiplier = 2;
                bossDamageTimer = 60000; // 1 minute
                diamonds -= 3;
                updateChallengeProgress('collect_diamonds', -1);
                updateChallengeProgress('bossWeakness', 1);
                console.log('Boss weakness purchased!');
                updateStatsDisplay();
            } else {
                alert('Not enough diamonds!');
            }
        }

        function buyDiamondShield() {
            if (diamonds >= 8) {
                diamondShield = 3; // Blocks 3 hits
                diamonds -= 8;
                updateChallengeProgress('collect_diamonds', -1);
                updateChallengeProgress('diamondShield', 1);
                console.log('Diamond shield purchased!');
                updateStatsDisplay();
            } else {
                alert('Not enough diamonds!');
            }
        }

        function buyDiamondStorm() {
            if (diamonds >= 15) {
                diamondStormActive = true;
                diamondStormTimer = 10000; // 10 seconds
                diamonds -= 15;
                updateChallengeProgress('collect_diamonds', -1);
                updateChallengeProgress('diamondStorm', 1);
                console.log('Diamond storm purchased!');
                updateStatsDisplay();
            } else {
                alert('Not enough diamonds!');
            }
        }

        function buyShip(shipType) {
            if (money >= ships[shipType].cost) {
                if (!availableShips.includes(shipType)) {
                    availableShips.push(shipType);
                }
                currentShip = shipType;
                money -= ships[shipType].cost;
                updateChallengeProgress('collect_money', -1);
                console.log(`Ship upgraded to: ${ships[shipType].name}`);
                updateStatsDisplay();
                
                // Apply ship stats
                const ship = ships[shipType];
                player.speed = 5 * ship.speed;
                shotCooldown = 200 / ship.fireRate;
                bulletDamage = ship.damage;
                lives = Math.floor(25 * ship.health);
            } else {
                alert('Not enough money!');
            }
        }

        function updateStatsDisplay() {
            if (!statsDisplay || !gameRunning) return;
            
            let powerText = 'Basic';
            if (playerPower === 'speed') powerText = 'Speed Boost';
            if (doubleShot) powerText += ' + Double Shot';
            if (shieldActive) powerText += ' + Shield';
            if (starPowerActive) powerText += ' + Star Power';
            if (fireRateBoost) powerText += ' + Fire Rate';
            if (scoreMultiplier > 1) powerText += ` + ${scoreMultiplier}x Score`;
            if (bulletDamage > 1) powerText += ` + Bullet Damage ${bulletDamage}`;
            if (diamondShield > 0) powerText += ` + Diamond Shield (${diamondShield} hits)`;
            if (diamondStormActive) powerText += ' + Diamond Storm';
            if (bossDamageMultiplier > 1) powerText += ` + Boss Weakness (${bossDamageMultiplier}x)`;
            if (currentShip !== 'basic') powerText += ` + ${ships[currentShip].name}`;

            statsDisplay.innerHTML = `
                <span>Power: ${powerText}</span>
                <span>Consecutive: ${consecutiveHits}</span>
                <span>Survival: ${survivalTime}s</span>
                <span>💵: ${money}</span>
                <span>💎: ${diamonds}</span>
            `;
        }

        // Initialize the game
        console.log('Game initialization complete');
        loadHighScores(); // Load high scores on page load
        loadLeaderboard(); // Load leaderboard on page load
        
        // Pause and Resume functionality
        function pauseGame() {
            if (gameRunning && !gamePaused) {
                gamePaused = true;
                console.log('⏸️ Game paused');
                showPauseMessage();
            }
        }
        
        function resumeGame() {
            if (gameRunning && gamePaused) {
                gamePaused = false;
                console.log('▶️ Game resumed');
                hidePauseMessage();
                requestAnimationFrame(gameLoop);
            }
        }
        
        function togglePause() {
            if (gamePaused) {
                resumeGame();
                document.getElementById('pauseBtn').textContent = '⏸️ Pause';
            } else {
                pauseGame();
                document.getElementById('pauseBtn').textContent = '▶️ Resume';
            }
        }
        
        function showPauseMessage() {
            // Draw pause overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#4a90e2';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('⏸️ PAUSED', canvas.width / 2, canvas.height / 2 - 50);
            
            ctx.fillStyle = '#87ceeb';
            ctx.font = '24px Arial';
            ctx.fillText('Press P or ESC to resume', canvas.width / 2, canvas.height / 2 + 20);
            ctx.fillText('Press M for menu', canvas.width / 2, canvas.height / 2 + 50);
        }
        
        function hidePauseMessage() {
            // Clear pause overlay by redrawing the game
            draw();
        }

        function buyForceField() {
            if (money >= 40) {
                shieldActive = true;
                shieldTimer = 900; // 15 seconds
                money -= 40;
                updateChallengeProgress('collect_money', -1);
                updateChallengeProgress('forceField', 1);
                console.log('Force field purchased!');
                updateStatsDisplay();
            } else {
                alert('Not enough money!');
            }
        }

        function buyInvincibilityCloak() {
            if (diamonds >= 12) {
                // Add invincibility effect
                player.invincible = true;
                setTimeout(() => {
                    player.invincible = false;
                }, 10000); // 10 seconds
                diamonds -= 12;
                updateChallengeProgress('collect_diamonds', -1);
                updateChallengeProgress('invincibilityCloak', 1);
                console.log('Invincibility cloak purchased!');
                updateStatsDisplay();
            } else {
                alert('Not enough diamonds!');
            }
        }

        function buyLifePack() {
            if (money >= 120) {
                lives += 3;
                money -= 120;
                updateChallengeProgress('collect_money', -1);
                updateChallengeProgress('lifePack', 1);
                console.log('Life pack purchased!');
                updateStatsDisplay();
            } else {
                alert('Not enough money!');
            }
        }

        function buyAutoRevive() {
            if (diamonds >= 6) {
                player.autoRevive = true;
                diamonds -= 6;
                updateChallengeProgress('collect_diamonds', -1);
                updateChallengeProgress('autoRevive', 1);
                console.log('Auto-revive purchased!');
                updateStatsDisplay();
            } else {
                alert('Not enough diamonds!');
            }
        }

        function buySpeedDemon() {
            if (money >= 35) {
                playerPower = 'speed';
                setTimeout(() => {
                    playerPower = 'basic';
                }, 20000); // 20 seconds
                money -= 35;
                updateChallengeProgress('collect_money', -1);
                updateChallengeProgress('speedDemon', 1);
                console.log('Speed demon purchased!');
                updateStatsDisplay();
            } else {
                alert('Not enough money!');
            }
        }

        function buyTimeWarp() {
            if (diamonds >= 10) {
                // Slow down enemies
                enemySpeedMultiplier *= 0.5;
                setTimeout(() => {
                    enemySpeedMultiplier /= 0.5;
                }, 15000); // 15 seconds
                diamonds -= 10;
                updateChallengeProgress('collect_diamonds', -1);
                updateChallengeProgress('timeWarp', 1);
                console.log('Time warp purchased!');
                updateStatsDisplay();
            } else {
                alert('Not enough diamonds!');
            }
        }

        function buyTripleShot() {
            if (money >= 45) {
                doubleShot = true;
                setTimeout(() => {
                    doubleShot = false;
                }, 25000); // 25 seconds
                money -= 45;
                updateChallengeProgress('collect_money', -1);
                updateChallengeProgress('tripleShot', 1);
                console.log('Triple shot purchased!');
                updateStatsDisplay();
            } else {
                alert('Not enough money!');
            }
        }

        function buyLaserBeam() {
            if (diamonds >= 8) {
                player.laserBeam = true;
                setTimeout(() => {
                    player.laserBeam = false;
                }, 12000); // 12 seconds
                diamonds -= 8;
                updateChallengeProgress('collect_diamonds', -1);
                updateChallengeProgress('laserBeam', 1);
                console.log('Laser beam purchased!');
                updateStatsDisplay();
            } else {
                alert('Not enough diamonds!');
            }
        }

        function buyMissileLauncher() {
            if (diamonds >= 7) {
                player.missileLauncher = true;
                setTimeout(() => {
                    player.missileLauncher = false;
                }, 30000); // 30 seconds
                diamonds -= 7;
                updateChallengeProgress('collect_diamonds', -1);
                updateChallengeProgress('missileLauncher', 1);
                console.log('Missile launcher purchased!');
                updateStatsDisplay();
            } else {
                alert('Not enough diamonds!');
            }
        }

        // PWA Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                console.log('Starting PWA setup...');
                
                // Register service worker without aggressive update checking
                navigator.serviceWorker.register('./sw.js?v=1.0.19')
                    .then(registration => {
                        console.log('SW registered successfully: ', registration);
                    })
                    .catch(registrationError => {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
        } else {
            console.log('Service Worker not supported');
        }

        function switchWeapon(weaponType) {
            if (weapons[weaponType]) {
                const previousWeapon = currentWeapon;
                currentWeapon = weaponType;
                console.log(`🔫 Switched weapon: ${weapons[previousWeapon].name} → ${weapons[weaponType].name}`);
                console.log(`   Damage: ${weapons[weaponType].damage}x | Fire Rate: ${weapons[weaponType].fireRate}x | Color: ${weapons[weaponType].color}`);
                
                // Track weapon switching event
                if (window.firebaseFunctions) {
                    window.firebaseFunctions.trackEvent('weapon_switched', {
                        from_weapon: previousWeapon,
                        to_weapon: weaponType,
                        weapon_name: weapons[weaponType].name,
                        weapon_damage: weapons[weaponType].damage,
                        weapon_fire_rate: weapons[weaponType].fireRate
                    });
                }
                
                // Show weapon switch message
                showWeaponSwitchMessage(weapons[weaponType].name);
            } else {
                console.error(`❌ Invalid weapon type: ${weaponType}`);
            }
        }
        
        function showWeaponSwitchMessage(weaponName) {
            // Create temporary weapon switch message
            const message = `Weapon: ${weaponName}`;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#00ff00';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(message, canvas.width / 2, canvas.height / 2);
            
            // Clear message after 1 second
            setTimeout(() => {
                // Message will be cleared in next frame
            }, 1000);
        }


    </script>
</body>
</html> 